import bag

const F = 1
const NSERVERS = (2 * F) + 1

network = bag.empty()

def send(m):
    atomic: network = bag.add(network, m)

def server():
    let t, v, received = (0, None), None, {}:
        while True:
            select m in { m for m in keys network - received where m.type in {.read, .write} }:
                received |= { m }
                if (m.type == .write) and (m.value[0] > t):
                    t, v = m.value
                send({ .type: .response, .dst: m.src, .value: (t, v) })

def receive(self, phase):
    let msgs = { m:c for m:c in network
                where (m.type == .response) and (m.dst == (self, phase)) }:
        result = bag.combinations(msgs, NSERVERS - F)

def read(self):
    send({ .type: .read, .src: (self, 1) })
    select msgs in receive(self, 1):
        let (t, v) = max(m.value for m in keys msgs):
            send({ .type: .write, .src: (self, 2), .value: (t, v) })
            result = v
    select msgs in receive(self, 2): pass

def write(self, v):
    send({ .type: .read, .src: (self, 1) })
    select msgs in receive(self, 1):
        let (t, _) = max(m.value for m in keys msgs)
        let nt = (t[0] + 1, self):
            send({ .type: .write, .src: (self, 2), .value: (nt, v) })
    select msgs in receive(self, 2): pass

def reader():
    let first = read((.reader, 1))
    let second = read((.reader, 2)):
        assert (first == 1) => (second == 1)

def writer():
    write((.writer, 1), 1)

for i in { 1 .. NSERVERS }: spawn eternal server()
spawn reader()
spawn writer()
