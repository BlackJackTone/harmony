from synch import *             # shared queue for file server and lock for superblock
from alloc import *             # malloc/free
from RW import *                # read/write locks for inode blocks
from list import subseq         # list slicing
from disk import *              # disk service

const N_BLOCKS = 10
const INODES_PER_BLOCK = 2      # number of inodes that fit in a block
const INDIR_PER_BLOCK = 4       # number of block pointers per block

# The file system consists of a superblock, an array of inode blocks, and
# the remaining blocks.  The remaining blocks are dynamic and can be of
# the following types:
#   - free: not in use
#   - data: a data block
#   - indir: an indirect block, with pointers to other blocks
# An inode has a pointer to a direct block and a pointer to an indirect block,
# so the maximum file size is 1 + INDIR_PER_BLOCK.

# Put block bno on the free list.  The free list is a linked list of
# indirect blocks.  The first entry in a free list block points to the
# next free list block.  The other entries point to free blocks.  The
# superblock points to the first free list block.
def fs_release(res_q, fs_state, bno):
    acquire(?fs_state->super_lock)
    var super = disk_read(fs_state->disk, 0)
    if super.free == None:
        disk_write(fs_state->disk, bno, [ None, ])
        super.free = bno
        disk_write(fs_state->disk, 0, super)
    else:
        let fb = disk_read(fs_state->disk, super.free):
            if len(fb) == INDIR_PER_BLOCK:
                # The first free list block is full
                disk_write(fs_state->disk, bno, [ super.free, ])
                super.free = bno
                disk_write(fs_state->disk, 0, super)
            else:
                disk_write(fs_state->disk, super.free, fb + [ bno, ])
    release(?fs_state->super_lock)

# Allocate a disk block
def fs_alloc(res_q, fs_state) returns bno:
    acquire(?fs_state->super_lock)
    var super = disk_read(fs_state->disk, 0)
    if super.free == None:
        bno = None
    else:
        let fb = disk_read(fs_state->disk, super.free):
            if len(fb) == 1:
                bno = super.free
                super.free = fb[0]
                disk_write(fs_state->disk, 0, super)
            else:
                bno = fb[len(fb) - 1]
                disk_write(fs_state->disk, super.free, subseq(fb, 0, len(fb) - 1))
    release(?fs_state->super_lock)

# Initialize the file system by writing the superblock, the i-node blocks,
# and creating the free list.
def fs_init(fs_state, n_inode_blocks):
    let res_q = malloc(Queue()):
        # Initialize the superblock
        disk_write(fs_state->disk, 0, { .n_inode_blocks: n_inode_blocks, .free: None })

        # Initialize the i-node blocks
        for i in { 1 .. n_inode_blocks }:
            disk_write(fs_state->disk, i, [
                { .direct: None, .indir: None, .size: 0 }, ] * INODES_PER_BLOCK)

        # Initialize the free list
        let n_disk_blocks = disk_getsize(fs_state->disk):
            for i in { n_inode_blocks + 1 .. n_disk_blocks - 1 }:
                fs_release(res_q, fs_state, i)

        free(res_q)

# Handle a read-only request.  A read lock on i-node block ib has been acquired.
def fs_query_request(res_q, fs_state, req, ib) returns result:
    # Read the inode block and extract the inode
    let inode_block = disk_read(fs_state->disk, 1 + ib)
    let inode = inode_block[req.ino % INODES_PER_BLOCK]:
        if req.type == "getsize":
            result = inode.size

        else:
            assert req.type == "read"

            # Read the direct block.  Return None if there is no direct block.
            if req.offset == 0:
                if inode.direct == None:
                    result = None
                else:
                    result = disk_read(fs_state->disk, inode.direct)

            # Read indirectly.  If there is no indirect block return None
            elif inode.indir == None:
                result = None

            # Read the indirect block and get the pointer to the data block,
            # which may be None.
            else:
                let indir = disk_read(fs_state->disk, inode.indir):
                    if indir[req.offset - 1] == None:
                        result = None
                    else:
                        result = disk_read(fs_state->disk, indir[req.offset - 1])

# Handle a write request.  A write lock on i-node block ib has been acquired.
def fs_update_request(res_q, fs_state, req, ib):
    assert req.type == "write"

    # Read the inode block and extract the inode
    var inode_block = disk_read(fs_state->disk, 1 + ib)
    var inode = inode_block[req.ino % INODES_PER_BLOCK]

    # Write the direct block.  Allocate one if needed, and if so update
    # the inode.  If not, just update the data block.
    if req.offset == 0:
        if inode.direct == None:
            inode.direct = fs_alloc(res_q, fs_state)
            inode.size = max(inode.size, 1)
            inode_block[req.ino % INODES_PER_BLOCK] = inode
            disk_write(fs_state->disk, 1 + ib, inode_block)
        disk_write(fs_state->disk, inode.direct, req.data)

    # Write a block indirectly
    else:
        # Allocate an indirect block first if there isn't one.  Note that
        # the inode block, indirect block, and data block must all be written
        if inode.indir == None:
            inode.indir = fs_alloc(res_q, fs_state)
            inode.size = max(inode.size, req.offset + 1)
            inode_block[req.ino % INODES_PER_BLOCK] = inode
            disk_write(fs_state->disk, 1 + ib, inode_block)
            let bno = fs_alloc(res_q, fs_state)
            let indir = [ bno if i == (req.offset - 1) else None
                            for i in { 0 .. INODES_PER_BLOCK - 1 } ]:
                disk_write(fs_state->disk, bno, req.data)
                disk_write(fs_state->disk, inode.indir, indir)

        # Read the indirect block first.  If needed allocate a data block,
        # otherwise just overwrite the existing data block.
        else:
            var indir = disk_read(fs_state->disk, inode.indir)
            if indir[req.offset - 1] == None:
                indir[req.offset - 1] = fs_alloc(res_q, fs_state)
                disk_write(fs_state->disk, inode.indir, indir)
            disk_write(fs_state->disk, indir[req.offset - 1], req.data)
            if inode.size <= req.offset:
                inode.size = req.offset + 1
                inode_block[req.ino % INODES_PER_BLOCK] = inode
                disk_write(fs_state->disk, 1 + ib, inode_block)

# Handle a request for the file server.  res_q is the response queue to the
# client, and req is the request
def fs_handle_request(res_q, fs_state, req):
    let ib = req.ino / INODES_PER_BLOCK:
        if req.type == "write":
            write_acquire(?fs_state->ib_locks[ib])
            fs_update_request(res_q, fs_state, req, ib)
            write_release(?fs_state->ib_locks[ib])
            put(req.q, "ok")
        else:
            read_acquire(?fs_state->ib_locks[ib])
            let response = fs_query_request(res_q, fs_state, req, ib):
                read_release(?fs_state->ib_locks[ib])
                put(req.q, response)

# A worker thread handles client requests
def fs_worker(fs_state):
    let res_q = malloc(Queue()):
        while True:
            fs_handle_request(res_q, fs_state, get(fs_state->req_q))

# The file server.  Initialize the file system and spawn worker threads
def file_server(req_q, n_inode_blocks, n_workers):
    # The in-memory shared state of the file server consists of:
    #   disk:       the shared disk
    #   req_q:      the request queue
    #   super_lock: lock on the superblock (and free list in particular)
    #   ib_locks:   read/write locks on inode blocks
    let d = disk_init(N_BLOCKS)
    let fs_state = malloc({
            .disk: d, .req_q: req_q, .super_lock: Lock(),
            .ib_locks: [ RWlock(), ] * n_inode_blocks }):

        # Initialize the file system on disk
        fs_init(fs_state, n_inode_blocks)

        # Start worker threads to handle client requests
        for i in { 1 .. n_workers }:
            spawn eternal fs_worker(fs_state)

#### FILE INTERFACE ####

def file_init(n_files) returns fs:
    fs = malloc(Queue())
    spawn file_server(fs,
        (n_files + (INODES_PER_BLOCK - 1)) / INODES_PER_BLOCK, 2)

def file_getsize(req_q, ino) returns size:
    let res_q = malloc(Queue()):
        put(req_q, { .type: "getsize", .ino: ino, .q: res_q })
        size = get(res_q)
        free(res_q)

def file_read(req_q, ino, offset) returns data:
    let res_q = malloc(Queue()):
        put(req_q, { .type: "read", .ino: ino, .offset: offset, .q: res_q })
        data = get(res_q)
        free(res_q)

def file_write(req_q, ino, offset, data):
    let res_q = malloc(Queue()):
        put(req_q, { .type: "write", .ino: ino, .offset: offset,
                                                .data: data, .q: res_q })
        let status = get(res_q):
            assert status == "ok"
        free(res_q)
