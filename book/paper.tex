\documentclass{report}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{framed}
\usepackage{tcolorbox}
\usepackage{verbatim}

\widowpenalty 10000
\clubpenalty 10000
\tolerance=9999
\newcommand{\tm}{\raisebox{.9ex}{\tiny tm}}

% \renewcommand{\topfraction}{.99}
% \renewcommand{\bottomfraction}{.99}
% \renewcommand{\textfraction}{.01}
% \renewcommand{\floatpagefraction}{.9}
% \renewcommand{\dbltopfraction}{.99}
% \renewcommand{\dblfloatpagefraction}{.9}

\newenvironment{code}{
\tcolorbox
}{
\endtcolorbox
}

\title{Concurrent Programming with CXL}
\author{RVR and others}

\begin{document}

\maketitle

\chapter{Introduction to Programming with CXL}

CXL is a concurrent programming language.  It was designed to teach
the basics of concurrent programming, but it is also useful for
testing new concurrent algorithms or even sequential and distributed
algorithms.  CXL programs are not intended to be ``run'' like programs
in most other programming languages---instead CXL programs are
``model checked'' to verify that the program has certain desirable
properties and does not suffer from bugs.  Model checking is
limited---it can only check programs that have ``finite state
spaces.''  But even programs that have infinite state spaces can
often be constrained (for example, by specifying a finite set of
possible inputs) so that model checking is possible.  If, for
example, a sorting algorithm is shown to work for any subset of
some set of say, 10, different values, then one can hope that it
will also work for sets that are larger than 10 values or sets that
use more than 10 values.

The syntax and semantics of CXL is similar to that of Python.
Python is familiar to many programmers and is easy to learn and
use.  We will assume that the reader is familiar with the basics
of Python programming.  We also will assume that the reader
understand some basics of machine architecture and how programs
are executed.

Like Python, CXL is an imperative,
dynamically typed and garbage collected programming language.
There are also some important differences:
\begin{itemize}
\item Every statement in CXL must be terminated by a semicolon
(even \texttt{while} statements and \texttt{def} statements);
in Python semicolons are optional and rarely used;
\item Correct indentation in CXL is encouraged but optional;
\item Python is object-oriented; CXL is not;
\item CXL does not support floating point;
\item CXL does not support I/O of any kind;
\item CXL does not support operator precedence or associativity.  Use
parentheses liberally to remove ambiguity.
\end{itemize}
There are also many unimportant ones that you will discover as
you get more familiar with programming in CXL.

\begin{figure}
\begin{code}
\verbatiminput{triangle.cxl}
\end{code}
\caption{Computing triangle numbers.}
\label{fig:triangle}
\end{figure}

Figure~\ref{fig:triangle} gives a simple example of a CXL program.
It is sequential and has a method \texttt{square} that takes
an integer number as argument.  Each method has a variable called
\texttt{result} that eventually contains the result of the
method (there is no \texttt{return} statement in CXL).  The method
also has a variable called \texttt{n} containing the value of the
argument.  The \texttt{x..y} notation generates a set containing the numbers
from~\texttt{x} to~\texttt{y} (inclusive).  The last two lines in the program are
the most interesting.
They assign to \texttt{x} some unspecified value in the range \texttt{0..N},
and then verifies the \texttt{assert} statement that $\mathtt{triangle}(x)$
equals $x(x+1)/2$.

``Running'' this CXL program will try all possible executions, which
includes all possible values for $x$.  Essentially, the $\texttt{choose}(S)$
operator provides the input to the program by selecting some value from the
set~$S$, while the $\texttt{assert}$ statement checks that the output is
correct.  If the program is correct, the output of CXL is the size of the
``state graph'' and its diameter (more on this later).  If not, CXL also
reports what went wrong, typically by displaying a summary of an execution in
which something went wrong.

\begin{quote}
Try it out!
\begin{itemize}
\item See what happens if, instead of initializing \texttt{result} to 0,
you initialize it to 1.
\item Write a similar program that computes squares.
\end{itemize}
\end{quote}

\chapter{The Problem of Concurrent Programming}

\begin{figure}
\begin{code}
\verbatiminput{Up.cxl}
\end{code}
\caption{Incrementing twice in parallel.}
\label{fig:inc}
\end{figure}

Concurrent programming, aka multithreaded programming, involves multiple
processes running in parallel while sharing variables.
Figure~\ref{fig:inc} presents a simple example.  The program defines a
method \texttt{process} that takes a parameter called \texttt{self}.
It also initializes two shared variables \texttt{count} and \texttt{done}.
The \texttt{process()} method increments \texttt{count} and sets \texttt{done[self]}
to \texttt{True}.
Next the program spawns two processes, each invoking \texttt{process}.
Afterward there are three processes---after
all, there was already one, and it spawned two new ones.  We will call
the one that was already there the \emph{main process}.

The main process waits for the two other processes to finish by polling
both \texttt{done} flags.
Finally, it verifies that the value of \texttt{count} equals 2.  If not,
it reports the actual value of \texttt{count}.

\begin{quote}
What will happen?
\begin{itemize}
\item Before you run the program, what do you think will happen?  Is the
program correct in that \texttt{count} will end up being 2?
\item What are the possible values of \texttt{count} at the time of the
\texttt{assert} statement?
(You may assume that \texttt{load} and \texttt{store} instructions of the
underlying architecture are atomic---in fact they are.)
\end{itemize}
\end{quote}

What is going on is that the CXL program is compiled to machine instructions,
and it is the machine instructions that are executed by the underlying
machine.  The details of this appear in the next chapter, but suffice it to
say that the machine has instructions that load values from memory and store
values into memory.  Importantly, it does not have instructions to atomically
increment or decrement values in memory locations.
So to increment a value in memory,
the machine must do at least three machine instructions.  Conceptually:
\begin{enumerate}
\item load the value from the memory location;
\item add 1 to the value;
\item store the value to the memory location.
\end{enumerate}

When running multiple processes, each essentially runs an instantiation of
the machine, and they do so in parallel.  As they execute, their machine
instructions are interleaved in unspecified and often random ways.
In fact, CXL will try \emph{all possible interleavings} of the processes
executing machine instructions.
The following is a possible interleaving of processes~0 and~1:
\begin{enumerate}
\item Process 0 loads the value of \texttt{count}, which is 0;
\item Process 1 loads the value of \texttt{count}, which is still 0;
\item Process 1 adds one to the value that it loaded (0), and
stores $1$ into \texttt{count};
\item Process 0 adds one to the value that it loaded (0), and
stores $1$ into \texttt{count};
\item Process 0 sets \texttt{upDone} to \texttt{True};
\item Process 1 sets \texttt{upDone} to \texttt{True}.
\end{enumerate}

The result in this particular interleaving is that \texttt{count} ends up
being 1.  When running CXL, it will
report violations of assertions.  It also provides an example
of an interleaving, like the one above, in which an assertion fails.

If one thinks of the assertion as providing the specification of the
program, then clearly its implementation does not satisfy its specification.
Either the specification or the implementation (or both) must have a bug.
We could change the specification by changing the assertion as follows:

\begin{code}
\begin{verbatim}
    assert (count == 0) or (count == 1);
\end{verbatim}
\end{code}

This would fix the issue, but more likely it is the program that must
be fixed.

\begin{quote}
Can you think of a fix to the program?  You can try it out and see
if it works or not.
\end{quote}

\chapter{The CXL Machine}
\label{ch:cxlmachine}

\begin{figure}
\begin{code}
\begin{verbatim}
Up.cxl:1 def process(self):
   0 Jump 12
   1 Frame ('process', 'Up.cxl', 1, 5) [('self', 'Up.cxl', 1, 13)] 11
Up.cxl:2     count = count + 1;
   2 Constant (1, 'Up.cxl', 2, 21)
   3 Load ('count', 'Up.cxl', 2, 13)
   4 Nary ('+', 'Up.cxl', 2, 19) 2
   5 Name ('count', 'Up.cxl', 2, 5)
   6 Store 1
Up.cxl:3     done[self] = True;
   7 Constant (True, 'Up.cxl', 3, 18)
   8 LoadVar ('self', 'Up.cxl', 3, 10)
   9 Name ('done', 'Up.cxl', 3, 5)
   10 Store 2
   11 Return
Up.cxl:5 count = 0;
   12 Constant (0, 'Up.cxl', 5, 9)
   13 Name ('count', 'Up.cxl', 5, 1)
   14 Store 1
\end{verbatim}
\end{code}
\caption{The first part of the machine code corresponding to Figure~\ref{fig:inc}.}
\label{fig:inccode}
\end{figure}

\begin{figure}
\begin{code}
\begin{verbatim}
==== Safety violation ====
__main__/() [0,12-31]           32 dict{ .count:0, .done:dict{ 0:False, 1:False } }
process /0  [1-5]                6 dict{ .count:0, .done:dict{ 0:False, 1:False } }
process /1  [1-10]              11 dict{ .count:1, .done:dict{ 0:False, 1:True  } }
process /0  [6-10]              11 dict{ .count:1, .done:dict{ 0:True,  1:True  } }
__main__/() [32-34,37-42,44-48] 49 dict{ .count:1, .done:dict{ 0:True,  1:True  } }
\end{verbatim}
\end{code}
\caption{The output of running Figure~\ref{fig:inc}.}
\label{fig:incoutput}
\end{figure}

Before we delve into how to solve synchronization problems, it is important
to know a bit about the underlying machine.  A CXL program is translated
into a list of machine instructions that the machine executes.
The CXL machine is not an ordinary virtual machine, but its architecture
is nonetheless representative of conventional machines such as hardware
with memory and CPUs and virtual machines such as the Java Virtual Machine.

Instead of bits and bytes, a CXL machine manipulates \emph{CXL values}.
CXL values are recursively defined: they include booleans, integers, strings,
sets of CXL values, and \emph{dictionaries} that map CXL values to other CXL
values.

A CXL machine has the following components:
\begin{itemize}
\item Code:  This is an immutable and finite list of CXL machine instructions,
generated from a CXL program.  The types of instructions will be described later.
\item Shared memory: A CXL machine has just one memory location containing
a CXL.
\item Processes:  Initially there is just the main process, but any process
can spawn an unbounded number of other processes and processes may terminate.
Each process has an immutable (but not necessarily unique) \emph{name tag},
a program counter, a stack of CXL values,
and a single mutable general purpose \emph{register} that contains a CXL.
\end{itemize}

A name tag consists of the name of the main method of the process,
along with the tag specified in the \texttt{spawn} statement.
In Figure~\ref{fig:inc}, the created processes have name tags
\texttt{process/0} and \texttt{process/1}.  The main process that
starts the execution has name tag \texttt{\_\_main\_\_/()}.

The state of a process is called a \emph{context}: it contains the value of
its name tag, program counter, stack, and register.
The state of the CXL machine
consists of the value of its memory and the multiset (or \emph{bag}) of
contexts.  It is a multiset of contexts because two different processes can
be in the same state.
The initial state of the CXL memory is the empty tuple, \texttt{()}.
The context bag has an initial context in it with name tag
\texttt{\_\_main\_\_/()}, pc 0, register \texttt{()}, and an empty stack.
(In CXL, dictionary values are enclosed by \texttt{dict\{} and \texttt{\}}.)
Each machine instruction updates the state in some way.
Figure~\ref{fig:incstate} shows an example of a reachable state for 
the program in Figure~\ref{fig:inc}.


It may seem strange that there is only one memory location and that each
process has only one register.  However, this is not a limitation because
CXL values are unbounded trees.
By convention, both the memory and the register of a process always contain
a special type of CXL value in which the root is a dictionary
that maps strings to CXL values.  We call this a \emph{directory}.
A directory represents the state of a collection of variables named by the strings.

Directories can be organized into a tree.  Each node in the tree is then identified
by a sequence of strings, like a path name in the file system hierarchy.  We call
such a sequence the \emph{address} of a CXL value.

Compiling the code in Figure~\ref{fig:inc} results in the CXL machine code
listed in Figure~\ref{fig:inccode}.
The CXL machine is predominantly a \emph{stack machine}.
Most instructions pop values from the stack or push values onto the stack.
Initially there is one process that starts executing at instruction 0.
In this case, there is a \texttt{JUMP} instruction that sets the program
counter to 22.  At program counter 1 is the code for the \texttt{up} method.
All methods start with a \texttt{Frame} instruction and end with a \texttt{Return}
instruction.

The \texttt{Frame} instruction has three arguments:
\begin{enumerate}
\item A token containing the name of the method;
\item A token containing the name of the argument of the method;
\item A program counter of the method's \texttt{Return} instruction.
\end{enumerate}

A \emph{token} is a four-tuple containing a \emph{lexeme}, a file name, a
line number in the file, and a column number in the file.  For example,
\texttt{(’up’, ’Up.cxl’, 1, 5)} represents the lexeme \texttt{up} in
file \texttt{Up.xcl}, line 1, column 5.  Tokens make it easy to relate
the CXL machine instructions to the CXL source code.

The code generated from \texttt{count := count + 1} in line 2 of
\texttt{Up.cxl} is as follows:

\begin{enumerate} \setcounter{enumi}{1}
\item the \texttt{Constant} instruction pushes the constant 1
onto the stack of the process.
\item The \texttt{Load} instruction loads the shared variable
\texttt{count} from the shared memory and pushes its value onto the
stack.
\item \texttt{Nary} stands for \texttt{n-ary}: in this case it is a \texttt{+}
operation with 2 arguments.  It pops two values from the stack, adds them,
and pushes the result back onto the stack.
\item The \texttt{Name} instruction pushes the address of the \texttt{count}
variable onto the stack.
\item The \texttt{Store} instruction pops the address of a variable and pops
a CXL value, and updates the memory by replacing the CXL value oat the given
address with the new CXL value.
\end{enumerate}

Figure~\ref{fig:incoutput} shows the output produced by running the
\texttt{Up.cxl} program.
It starts by reporting that the assertion on line 12 failed and that
\texttt{count} has value 1 instead of 0:
\texttt{Assertion failed (’assert’, ’Up.cxl’, 12, 1) 1}.
Next it reports an execution that failed this assertion.  The output has
five columns:
\begin{enumerate}
\item The entry point of the process (\texttt{\_\_main\_\_} for the main process);
\item The tag of the process (in this case always 0);
\item The sequence of program counters of the CXL machine instructions that the process executed;
\item The current program counter of the process;
\item The contents of the shared memory.
\end{enumerate}

If we look at the middle three rows, we see that:
\begin{enumerate}
\item Process 0 executed instructions 1 through 5, loading the value of
\texttt{count} but stopping just before storing 1 into \texttt{count};
\item Process 1 executed instructions 1 through 10, storing 1 into
into \texttt{count} and storing \texttt{True} into \texttt{done[2]};
\item Process 0 continues execution, storing value 1 into \texttt{count}
and storing \texttt{True} into \texttt{done[1]}.
\end{enumerate}

This makes precise the concurrency problem that we encountered.

\chapter{Critical Sections}

\begin{figure}
\begin{code}
\verbatiminput{csbarebones.cxl}
\end{code}
\caption{A barebones critical section.}
\label{fig:csbarebones}
\end{figure}

\begin{figure}
\begin{code}
\verbatiminput{cs.cxl}
\end{code}
\caption{CXL model of a critical section.}
\label{fig:cs}
\end{figure}

Hopefully you have started thinking of how to solve the concurrency
problem and you may already have prototyped some solutions.
In this chapter we will go through a few reasonable but broken attempts.
At the heart of the problem is that we would like make sure that when
the \texttt{count} variable is being updated that no other process is
trying to do the same thing.  We call this a \emph{critical section}: a
set of instructions where only one process is allowed to execute at a
time.

A critical section is often modeled as processes in an infinite loop
entering and exiting the critical section.  In CXL:

\begin{code}
\begin{verbatim}
while True:
    @ncs: pass; # in non-critical section
    # enter critical section
    @cs: pass;  # in critical section
    # exit critical section
;
\end{verbatim}
\end{code}

Here \texttt{@ncs} and \texttt{@cs} are \emph{labels}, each identifying
a location in the CXL machine code.  The first thing we need to
ensure is that there cannot be two processes at the critical section.
We would like to place an assertion at the \texttt{@cs} label that
specifies that only the current process can be there.  CXL in fact
supports this.  It has a method \texttt{atLabel($L$)}, where $L$
is the string name of a label (in this case, \texttt{"cs"}).  The
method returns a bag of name tags of processes executing at that
label.  The bag is represented by a dictionary that maps each element
in the bag to the number of times the element appears in the bag.

Figure~\ref{fig:csbarebones} shows the code.
The assertion also makes use of the method \texttt{nametag()} that
returns the name tag of the current process.
If you run the code through CXL, the assertion should fail because
there is no code yet for entering and exiting the critical section.

However, mutual exclusion by itself easy to ensure.
For example, we could insert the following code to enter the
critical section:
\begin{code}
\begin{verbatim}
while True: pass;;
\end{verbatim}
\end{code}
This code will surely prevent two or more processes from being
at label \texttt{cs} at the same time.
But it does so by preventing \emph{any} process from reaching
the critical section.
We clearly need another property besides mutual exclusion.

Mutual exclusion is an example of a \emph{safety property}, a
property that ensures that \emph{nothing bad will happen}, in this case
two processes being in the critical section.
What we need now a \emph{liveness property}: we want to ensure that
\emph{eventually something good will happen}.
There are various possible liveness properties we could use,
but here we will propose the following informally: if some set of processes
$S$ are trying to enter the critical section, then eventually one process in
$S$ will enter the critical section if any process already in the
intersection eventually leaves, even if no processes other than $S$ ever
try to enter the critical section.
We call this \emph{progress}.

In order to detect violations of progress, and other liveness problems in
algorithms in general, CXL requires that every execution must be
able to reach a state in which all processes have terminated.
Clearly, even if mutual exclusion holds in Figure~\ref{fig:csbarebones},
the spawned processes never terminate.  In order to resolve this, we
will model processes in critical regions using the framework in
Figure~\ref{fig:cs}: a process can \emph{choose} to enter a
critical region more than once, but it can also choose to terminate, even
without entering the critical region ever.
Note also that we have dropped the \texttt{@ncs} label: it would serve no
specific purpose.

\begin{quote}
Try it out!
\begin{itemize}
\item Plug \texttt{while True: pass;;} for entering the critical region
in Figure~\ref{fig:cs} and run CXL.  It should print a trace
to a state from which a terminating state cannot be reached.
\end{itemize}
\end{quote}


\chapter{Na\"{\i}ve Attempts at Implementing Critical Sections}

\begin{figure}
\begin{code}
\verbatiminput{UpLock.cxl}
\end{code}
\caption{Na\"{\i}ve implementation of a lock.}
\label{fig:uplock}
\end{figure}

\begin{figure}
\begin{code}
\verbatiminput{UpFlags.cxl}
\end{code}
\caption{Na\"{\i}ve use of flags to solve mutual exclusion.}
\label{fig:upflags}
\end{figure}

\begin{figure}
\begin{code}
\verbatiminput{UpTurn.cxl}
\end{code}
\caption{Na\"{\i}ve use of turn variable to solve mutual exclusion.}
\label{fig:upturn}
\end{figure}

Figure~\ref{fig:uplock} presents a solution based on a na\"{\i}ve implementation
of a \emph{lock}.
The idea is that the lock is a baton that at most one process can own at
a time.
Initially the lock is not owned, indicated by lock being \texttt{False}.
To enter the critical section, a process waits until lock is \texttt{False}
and then sets it to \texttt{True} to indicate that the lock has been taken.
The process then executes the critical section.  Finally the process
releases the lock by setting it back to \texttt{False}.

Unfortunately, if we run the program, we find that the assertion still
fails.  Diagnosing the problem, we see that the \texttt{lock} variable
suffers from the same problem as the \texttt{count} variable
in Figure~\ref{fig:inc}: operations
on it consist of several instructions are divisible.  It is thus possible
for both processes to believe the lock is available and obtain the lock
at the same time.

Figure~\ref{fig:upflags} presents a solution based on each process having
a flag indicating that it is trying to enter the critical section.
A process can write its own flag and read the flag of its peer.
After setting its flag, the process waits until the other process
(\texttt{1 - self}) is not trying to enter the critical section.
If we run this program, the assertion does not fail.  In fact, this
solution does prevent both processes being in the critical section at
the same time.
However, it has a different problem called livelock: if both try to
enter the critical section at the same time, they may end up waiting for
one another.

The final na\"{\i}ve solution is based on a variable called \texttt{turn}
that alternates between 0 and 1.  When \texttt{turn = $i$}, process~$i$ can
enter the critical section, while process $1-i$ has to wait.  When done,
process~$i$ sets \texttt{turn} to $1-i$ to give the other process an
opportunity to enter.
The solution has the nice properties that it satifies mutual exclution and,
moreover, processes 0 and 1 alternate entering the critical section.
The problem with the solution is
that it violates the \emph{progress} property:
if process~$i$ terminates instead of entering the critical section when it
is process~$i$'s turn, process $1-i$ ends up waiting indefinitely for its
turn.

\chapter{Peterson's Algorithm}

\begin{figure}
\begin{code}
\verbatiminput{../Peterson.cxl}
\end{code}
\caption{Peterson's Algorithm}
\label{fig:peterson}
\end{figure}

In 1981, Peterson came up with a beautiful solution to the mutual exclusion
problem, now known as ``Peterson's Algorithm''~\cite{Peterson81}.
The algorithm is an amalgam of the (incorrect) algorithms in
Figures~\ref{fig:upflags} and~\ref{fig:upturn}, and is presented
in Figure~\ref{fig:peterson}.
A process first indicates its interest in entering the critical section
by setting its flag.
It then politely gives way to the other process should it also want to
enter the critical section---if both do so at the same time one will
win because writes to memory in CXL are atomic.
The process continues to be polite, waiting in a \texttt{while} loop
until either the other process is no where near the critical section
or has given way.
Running the algorithm though CXL shows that it satisfies both mutual
exclusion and progress.

Why does it work?  We will focus here on how one might go about proving
mutual exclusion for an algorithm such as Peterson's.
For that, we have to understand a little bit more about how the CXL
machine works.
In Chapter~\ref{ch:cxlmachine} we talked about the concept of \emph{state}:
at any point of time the CXL machine is in a specific state.
Everytime a process executes a CXL machine instruction, the
state changes (if only because the program counter of the process is
updated).  We call that a \emph{step}.  Steps in CXL are atomic.

The CXL machine starts in an initial state in which there is only
one process and its program counter is~0.  A \emph{trace} is a
sequence of steps starting from the initial state.  When making a
step, there are two sources of non-determinism in CXL.  One is when
in some state more than one process can make a step.  The other is
when a process executes a \texttt{choose} operation and there is
more than one choice.

A good way to prove mutual exclusion is through induction on
the number of steps.
In such a proof, we need a so-called
\emph{inductive invariant} $I$, which is some predicate that holds
over the state.  We need $I$ to satisfy the following:
\begin{itemize}
\item (ME1) $I$ should imply mutual exclusion.
\item (ME2) $I$ should hold in the initial state.
\item (ME3) If $I$ holds over some state $s$, and some process in the
state takes a step, then $I$ should also hold in the resulting state.
\end{itemize}

One candidate for such an invariant is mutual exclusion itself.
After all, it certainly satisfies ME1 and ME2.
And as CXL has already determined, mutual exclusion is an invariant:
it holds over every \emph{reachable state}.
Unfortunately, it is not an \emph{inductive} invariant and therefore does
not satisfy ME3.
To see why, we need to consider an \emph{unreachable} state.
It is easy to construct one: let process~0 be at label \texttt{@cs}
and process~1 at the start of the \texttt{while} loop.
Also imagine that in this particular state $\mathtt{turn} = 1$.  Now let
process process~1 make a sequence of steps.  Because $\mathtt{turn} = 1$,
process~1 will break out of the while loop and also enter the critical
section, violating mutual exclusion.
Doing a inductive proof with an invariant that is not inductive is usually
much harder than doing one with an invariant that is.

\begin{figure}
\begin{code}
\verbatiminput{../PetersonProof.cxl}
\end{code}
\caption{Peterson's Algorithm with Inductive Invariant}
\label{fig:petersonproof}
\end{figure}

Let $C(\mathtt{self}) = \mathtt{flags}[1 - \mathtt{self}] \land
\mathtt{turn} = 1 - \mathtt{self}$, that is, the condition on the \texttt{while} loop.
For Peterson's Algorithm, an inductive invariant that works well is:
if process $i$ is label \texttt{@cs} (i.e., process $i$ is in the critical section),
then $C(i)$ does not hold or process $1-i$ is executing after setting
$\mathtt{flags}[i]$ but still before setting \texttt{turn} to $1-i$.
Let's call it $I_p(i)$.

Figure~\ref{fig:petersonproof} formalizes $I_p(i)$ in CXL.
The figure uses the CXL \texttt{atomic} statement for the first time.
For now, all you need to know is that it turns the embedded statement into
a single atomic step.  The label \texttt{@gate} thus refers exactly to
this statement.  You can run Figure~\ref{fig:petersonproof} to determine
that $I_p(i)$ is indeed an invariant for $i = 0, 1$.

To see that $I_p(i)$ implies mutual exclusion, suppose not.  Then
when both process~0 and process~1 are in the critical section, the
following must hold:
$(\lnot C(0) \lor \mathtt{process}(1)@gate) \land
 (\lnot C(1) \lor \mathtt{process}(0)@gate)$.
We know that both flags are set.
We also know that neither process~0 nor process~1 is at label \texttt{@gate}
(because they are both at label \texttt{@cs}),
so this simplifies to $(\lnot C(0)) \land (\lnot C(1))$.
So we conclude that $\mathtt{turn} = 0 \land \mathtt{turn} = 1$, a
logical impossibility.  Thus $I_p(i)$ satisfies ME1.

$I_p(i)$ satisfies ME2 trivially, because in the initial state no process
is in the critical section.

Finally we have to show that $I_p(i)$ satisfies ME3. Without loss of
generality, suppose $i=0$ (a benefit from the fact that the algorithm is
symmetric for both processes).  We have to show that if we are in a state
in which $I_p(0)$ holds, then any step will result in a state in which
$I_p(0)$ continues to hold.
Since $I_p(0)$ holds, process~0 is at label \texttt{@cs}.  If process~0
were to take a step, then in the next state process~0 would be no longer
at that label and $I_p(0)$ would hold trivially over the next state.
Therefore we only need to consider a step by process~1.

From $I_p(0)$ we know that one of the following cases must hold before
process~1 takes a step:
\begin{itemize}
\item \texttt{flags[1] = False};
\item \texttt{turn = 0};
\item process~1 is at label \texttt{@gate}.
\end{itemize}

Let us consider each of these cases.
In the first case, if process~1 takes a step, there are two possibilities:
either $flags[1]$ will still be \texttt{False} (in which case the first case
continues to hold), or $flags[1]$ will be \texttt{True}
and process~1 will be at label \texttt{@gate} (in which case the third case
will hold).
We know that process~1 never sets \texttt{turn} to 1, so
if the second case holds before the step, it will also hold after the step.
Finally, if process~1 is at label \texttt{@gate} before the step, then after
the step \texttt{turn} will equal 0, and therefore the second case will hold
after the step.

We have now demonstrated mutual exclusion in Peterson's Algorithm in two
different ways: one by letting CXL explore all possible executions, the
other using an inductive invariant and proof by induction.  The former
is certainly easier, but it does not provide intuition for why the
algorithm works.  The second provides much more insight.  We therefore
encourage to include inductive invariants in your CXL code.

A cool anecdote is the following.  When the author of CXL had to teach
Peterson's Algorithm, he refreshed his memory by looking at the Wikipedia
page.  The page claimed that the following predicate was invariant:
if process $i$ is in the critical section, then $\lnot C(i)$ (i.e.,
$I_p(i)$ without the disjunct that process $1-i$ is at label \texttt{gate}).
To demonstrate that this predicate is not invariant, you can remove the
disjunct from Figure~\ref{fig:petersonproof} and run it to get a
counterexample.

This anecdote suggests the following.  If you need to do an induction
proof of an algorithm, you have to come up with an inductive invariant.
Before trying to prove the algorithm, you can check that the predicate is
at least invariant by testing it using CXL.  Doing so could potentially
avoid wasting your time on a proof that will not work because the
predicate is not invariant, and therefore not an inductive invariant either.

To finish the story, the author of CXL fixed the Wikipedia page, but there
is another cool story.  Years later a colleague of the author, teaching
the same course, asked if the first two assignments (setting \texttt{flags[self]})
to \texttt{True} and \texttt{turn} to \texttt{1 - self}) can be reversed.
After all, they are different variables assigned independent values---in a
sequential program one could surely swap the two assignments.

\begin{quote}
What do you think?
\begin{itemize}
\item See if you can figure out for yourself if the two assignments can be
reversed.  Then run the program in Figure~\ref{fig:peterson} after reversing
the two assignments and see what happens.
\end{itemize}
\end{quote}

\begin{quote}
Bonus question!
\begin{itemize}
\item Can you generalize Peterson's algorithm to more than two processes?
\end{itemize}
\end{quote}

\chapter{CXL Methods and Dictionaries}

CXL methods look and feel much the same as Python methods, but there
are some differences you should be aware of.
First, as already noted, there is no \texttt{return} statement.
A CXL method returns when the last statement in the method has
completed.

Like in Python, CXL methods have local variables.  You have already
seen two types of local variables.
First, the arguments to the method are variables, although read-only.
Second, the variable \texttt{result} can be assigned to
change the default return value of a method, which is \texttt{()}.
You can declare additional local variables to hold intermediate
results.  For example, you can
declare a local variable $x$ with initial value 3 as follows:
\begin{code}
\begin{verbatim}
var x = 3;
\end{verbatim}
\end{code}
The initial value is mandatory.
Unless a variable is declared this way, it will be considered
a global shared variable.
The local variables of a method cannot be accessed other than by
the method itself.

A method \texttt{m} with argument \texttt{a} is invoked in its
most basic form as follows (assigning the result to \texttt{x}).
\begin{code}
\begin{verbatim}
var x = m a;
\end{verbatim}
\end{code}
That's right, no parentheses are required.  In fact, if you invoke
\texttt{m(a)}, the argument is \texttt{(a)}, which is the same
as \texttt{a}.
If you invoke \texttt{m()}, the argument is \texttt{()},
which is the empty tuple.  If you invoke
If you invoke \texttt{m(a, b)}, the argument is \texttt{(a, b)},
the tuple consisting of values \texttt{a} and \texttt{b}.
You have already seen examples of this: the expression
\texttt{atLabel.cs} invokes method \texttt{atLabel} with
argument \texttt{.cs}.

If you want to invoke a method but are not interested in its result,
you have to use a \texttt{call} statement like so:
\begin{code}
\begin{verbatim}
call m a;
\end{verbatim}
\end{code}

\chapter{Spinlock}
Figure~\ref{fig:uplock} showed a faulty attempt at solving mutual exclusion.

\end{document}
