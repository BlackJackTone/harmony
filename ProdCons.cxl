const N = 2;         // size of bounded buffer

routine tas(self):
    atomic:
        var oldval = !(self);
        !(self) := True;
        self := oldval;
    end atomic
end routine

routine lock(lk):
    while tas(lk): end while
end routine

routine unlock(lk):
    !(lk) := False;
end routine

routine produce(item):
    var full = True;
    while full:
        call lock &(mylock);
        if cnt < N:
            full := False;
        else:
            assert cnt == N: cnt;
            call unlock &(mylock);
        end if
    end while

    @room:
        cnt := cnt + 1;
        // buf[myin] := choose({ 10, 20 });
        buf[myin] := item;
        myin := (myin + 1) % N;

    call unlock &(mylock);
end routine

routine consume(self):
    var empty = True;
    while empty:
        call lock &(mylock);
        if cnt > 0:
            empty := False;
        else:
            assert cnt == 0: cnt;
            call unlock &(mylock);
        end if
    end while

    @avail:
        cnt := cnt - 1;
        self := buf[myout];
        myout := (myout + 1) % N;

    call unlock &(mylock);
end routine

routine producer(self):
    while True:
        call produce[choose({ 10, 20 })];
    end while
end routine

routine consumer():
    while True:
        call consume();
    end while
end routine

buf := R{ x:0 | x in 0..(N-1) };
myin := 0;
myout := 0;
cnt := 0;
mylock := False;

spawn producer(0), 0;
spawn producer(1), 1;
spawn consumer(), 2;
spawn consumer(), 3;
