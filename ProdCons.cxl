const N = 2;         # size of bounded buffer

def tas(self):
    atomic:
        var oldval = !(self);
        !(self) := True;
        self := oldval;
    end atomic
end def

def lock(lk):
    while tas(lk): end while
end def

def unlock(lk):
    !(lk) := False;
end def

def produce(item):
    var full = True;
    while full:
        call lock &(mylock);
        if cnt < N:
            full := False;
        else:
            assert cnt == N: cnt;
            call unlock &(mylock);
        end if
    end while

    @room:
        cnt := cnt + 1;
        # buf[myin] := choose({ 10, 20 });
        buf[myin] := item;
        myin := (myin + 1) % N;

    call unlock &(mylock);
end def

def consume(self):
    var empty = True;
    while empty:
        call lock &(mylock);
        if cnt > 0:
            empty := False;
        else:
            assert cnt == 0: cnt;
            call unlock &(mylock);
        end if
    end while

    @avail:
        cnt := cnt - 1;
        self := buf[myout];
        myout := (myout + 1) % N;

    call unlock &(mylock);
end def

def producer():
    while True:
        call produce[choose({ 10, 20 })];
    end while
end def

def consumer():
    while True:
        call consume();
    end while
end def

# buf := R{ x:0 | x in 0..(N-1) };
buf := R{ 0:0, 1:0 };
myin := 0;
myout := 0;
cnt := 0;
mylock := False;

spawn producer(), 0;
spawn producer(), 0;
spawn consumer(), 1;
spawn consumer(), 1;
