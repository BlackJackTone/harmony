\documentclass{report}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{framed}
\usepackage{tcolorbox}
\usepackage{verbatim}

\widowpenalty 10000
\clubpenalty 10000
\tolerance=9999
\newcommand{\tm}{\raisebox{.9ex}{\tiny tm}}

% \renewcommand{\topfraction}{.99}
% \renewcommand{\bottomfraction}{.99}
% \renewcommand{\textfraction}{.01}
% \renewcommand{\floatpagefraction}{.9}
% \renewcommand{\dbltopfraction}{.99}
% \renewcommand{\dblfloatpagefraction}{.9}

\newenvironment{code}{
\tcolorbox
}{
\endtcolorbox
}

\title{Concurrent Programming with CXL}
\author{RVR and others}

\begin{document}

\maketitle

\chapter{Introduction to Programming with CXL}

CXL is a concurrent programming language.  It was designed to teach
the basics of concurrent programming, but it is also useful for
testing new concurrent algorithms or even sequential and distributed
algorithms.  CXL programs are not intended to be ``run'' like programs
in most other programming languages---instead CXL programs are
``model checked'' to verify that the program has certain desirable
properties and does not suffer from bugs.  Model checking is
limited---it can only check programs that have ``finite state
spaces.''  But even programs that have infinite state spaces can
often be constrained (for example, by specifying a finite set of
possible inputs) so that model checking is possible.  If, for
example, a sorting algorithm is shown to work for any subset of
some set of say, 10, different values, then one can hope that it
will also work for sets that are larger than 10 values.

The syntax and semantics of CXL is similar to that of Python.
Python is familiar to many programmers and is easy to learn and
use.  We will assume that the reader is familiar with the basics
of Python programming.  We also will assume that the reader
understand some basics of machine architecture and how programs
are executed.

Like Python, CXL is an imperative,
dynamically typed and garbage collected programming language.
There are also some important differences:
\begin{itemize}
\item Every statement in CXL must be terminated by a semicolon
(even \textbf{while} statements and \textbf{def} statements);
in Python semicolons are optional and rarely used;
\item Correct indentation in CXL is encouraged but optional;
\item Python is object-oriented; CXL is not;
\item CXL does not support floating point or lists natively;
\item CXL does not support I/O of any kind;
\item CXL does not support operator precedence or associativity.  Use
parentheses liberally to remove ambiguity.
\end{itemize}
There are also many unimportant ones that you will discover as
you get more familiar with programming in CXL.

\begin{figure}
\begin{code}
\verbatiminput{triangle.cxl}
\end{code}
\caption{Computing triangle numbers.}
\label{fig:triangle}
\end{figure}

Figure~\ref{fig:triangle} gives a simple example of a CXL program.
It is sequential and has a method \texttt{square} that takes
an integer number as argument.  Each method has a variable called
\texttt{result} that eventually contains the result of the
method (there is no \texttt{return} statement in CXL).  The method
also has a variable called \texttt{n} containing the value of the
argument.  The $x..y$ notation generates a set containing the numbers
from $x$ to $y$ (inclusive).  The last two lines in the program are
the most interesting.
They assign to $x$ some unspecified value in the range $0..N$, and then
verifies the \texttt{assert} statement that $\mathtt{triangle}(x)$
equals $x(x+1)/2$.
If the verification fails, the value of $x$ is reported.
(The syntax of a CXL \texttt{assert} statement is the same as in Python
except that the ``,'' clause is not optional.)

``Running'' this CXL program will try all possible executions, which
includes all possible values for $x$.  Essentially, the $\texttt{choose}(S)$
operator provides the input to the program by selecting some value from the
set $S$, while the $\texttt{assert}$ statement checks that the output is
correct.  If the program is correct, the output of CXL is the size of the
``state graph'' and its diameter (more on this later).  If not, CXL also
reports what went wrong, typically by displaying a summary of an execution in
which something went wrong.

\begin{quote}
Try it out!
\begin{itemize}
\item See what happens if, instead of initializing \texttt{result} to 0,
you initialize it to 1.
\item Write a similar program that computes squares.
\end{itemize}
\end{quote}

\chapter{The Problem of Concurrent Programming}

\begin{figure}
\begin{code}
\verbatiminput{Up.cxl}
\end{code}
\caption{Incrementing twice in parallel.}
\label{fig:inc}
\end{figure}

Concurrent programming, aka multithreaded programming, involves multiple
processes running in parallel while sharing variables.
Figure~\ref{fig:inc} presents a simple example.  The program defines a
method \texttt{up} that takes a parameter called \texttt{self}.
It also initializes two shared variables \texttt{count} and \texttt{done}.
Variable \texttt{done} is initialized with a dictionary that maps both 1 and 2
to \texttt{False}.
The \texttt{up()} method increments \texttt{count} and sets \texttt{done[self]}
to \texttt{True}.
Next the program spawns two processes, each invoking \texttt{up}.
Afterward there are three processes---after
all, there was already one, and it spawned two new ones.  We will call
the one that was already there the \emph{main process}.

The main process waits for the two other processes to finish by polling
both \texttt{done} flags.
Finally, it verifies that the value of \texttt{count} equals 2.  If not,
it reports the actual value of \texttt{count}.

\begin{quote}
What will happen?
\begin{itemize}
\item Before you run the program, what do you think will happen?  Is the
program correct in that \texttt{count} will end up being 2?
\item What are the possible values of \texttt{count} at the time of the
\texttt{assert} statement?
(You may assume that \texttt{load} and \texttt{store} instructions of the
underlying architecture are atomic---in fact they are.)
\end{itemize}
\end{quote}

What is going on is that the CXL program is compiled to machine instructions,
and it is the machine instructions that are executed by the underlying
machine.  The details of this appear in the next chapter, but suffice it to
say that The machine has instructions that load values from memory and store
values into memory.  Importantly, it does not have instructions to atomically
increment or decrement values in memory locations.
So to increment a value in memory,
the machine must do at least three machine instructions.  Conceptually:
\begin{enumerate}
\item load the value from the memory location;
\item add 1 to the value;
\item store the value to the memory location.
\end{enumerate}

When running multiple processes, each essentially runs an instantiation of
the machine, and they do so in parallel.  As they execute, their machine
instructions are interleaved in unspecified and often random ways.
In fact, CXL will try \emph{all possible interleavings} of the processes
executing machine instructions.
And thus, the following is a possible interleaving of
the processes 1 and 2:
\begin{enumerate}
\item Process 1 loads the value of \texttt{count}, which is 0;
\item Process 2 loads the value of \texttt{count}, which is still 0;
\item Process 2 adds one to the value that it loaded (0), and
stores $1$ into \texttt{count};
\item Process 1 adds one to the value that it loaded (0), and
stores $1$ into \texttt{count};
\item Process 1 sets \texttt{upDone} to \texttt{True};
\item Process 2 sets \texttt{upDone} to \texttt{True}.
\end{enumerate}

The result in this particular interleaving is that \texttt{count} ends up
being 1.  When running CXL, it will
report the violations of the assertions.  It also provides an example
of an interleaving, like the one above, of how exactly the assertion
ended up failing.

If one thinks of the assertion as providing the specification of the
program, then clearly its implementation does not satisfy its specification.
Either the specification or the implementation (or both) must have a bug.
We could change the specification by changing the assertion as follows:

\begin{code}
\begin{verbatim}
    assert (count == 0) or (count == 1), count;
\end{verbatim}
\end{code}

This would fix the issue, but more likely it is the program that must
be fixed.

\begin{quote}
Can you think of a fix to the program?  You can try it out and see
if it works or not.
\end{quote}

\chapter{The CXL Machine}

\begin{figure}
\begin{code}
\begin{verbatim}
Up.cxl:1 def up(self):
   0 Jump 12
   1 Frame ('up', 'Up.cxl', 1, 5) ('self', 'Up.cxl', 1, 8) 11
Up.cxl:2     count = count + 1;
   2 Constant (1, 'Up.cxl', 2, 21)
   3 Load ('count', 'Up.cxl', 2, 13)
   4 Nary ('+', 'Up.cxl', 2, 19) 2
   5 Name ('count', 'Up.cxl', 2, 5)
   6 Store 1
Up.cxl:3     done[self] = True;
   7 Constant (True, 'Up.cxl', 3, 18)
   8 LoadVar ('self', 'Up.cxl', 3, 10)
   9 Name ('done', 'Up.cxl', 3, 5)
   10 Store 2
   11 Return
Up.cxl:5 count = 0;
   12 Constant (0, 'Up.cxl', 5, 9)
   13 Name ('count', 'Up.cxl', 5, 1)
   14 Store 1
\end{verbatim}
\end{code}
\caption{The first part of the machine code corresponding to Figure~\ref{fig:inc}.}
\label{fig:inccode}
\end{figure}

\begin{figure}
\begin{code}
\begin{verbatim}
Assertion failed ('assert', '<stdin>', 12, 1) 1

==== Safety violation ====
__main__ 0 [0,12-29]     30 { 'count': 0, 'done': { 1: False, 2: False } }
up       1 [1-5]          6 { 'count': 0, 'done': { 1: False, 2: False } }
up       2 [1-10]        11 { 'count': 1, 'done': { 1: False, 2: True  } }
up       1 [6-10]        11 { 'count': 1, 'done': { 1: True,  2: True  } }
__main__ 0 [30-37,39-44] 44 { 'count': 1, 'done': { 1: True,  2: True  } }
\end{verbatim}
\end{code}
\caption{The output of running Figure~\ref{fig:inc}.}
\label{fig:incoutput}
\end{figure}

Before we delve into how to solve synchronization problems, it is important
to know a bit about the underlying machine.  A CXL program is translated
into a list of machine instructions that the machine executes.
The CXL machine is not an ordinary virtual machine, but its architecture
is nonetheless representative of conventional machines such as hardware
with memory and CPUs and virtual machines such as the Java Virtual Machine.

Instead of bits and bytes, a CXL machine manipulates \emph{CXL values}.
CXL values are recursively defined: they include booleans, integers, strings,
sets of CXL values, and \emph{dictionaries} that map CXL values to other CXL
values.

A CXL machine has the following components:
\begin{itemize}
\item Code:  This is an immutable and finite list of CXL machine instructions,
generated from a CXL program.  The types of instructions will be described later.
\item Shared memory: A CXL machine has just one memory location containing
a CXL.
\item Processes:  Initially there is just the main process, but any process
can spawn an unbounded number of other processes and processes may terminate.
Each process has an immutable tag, a program counter, a stack of CXL values,
and a single mutable general purpose \emph{register} that contains a CXL.
\end{itemize}

The state of a process is called a \emph{context}: it contains the value of
its program counter, stack, and register.  The state of the CXL machine
consists of the value of its memory and the multiset (or \emph{bag}) of
contexts.  It is a multiset of contexts because two different processes can
be in the same state.

It may seem strange that there is only one memory location and that each
process has only one register.  However, this is not a limitation because
CXL values are unbounded trees.
By convention, both the memory and the register of a process always contain
a special type of CXL value in which the root is a dictionary
that maps strings to CXL values.  We call this a \emph{directory}.
A directory represents the state of a collection of variables named by the strings.

Directories can be organized into a tree.  Each node in the tree is then identified
by a sequence of strings, like a path name in the file system hierarchy.  We call
such a sequence the \emph{address} of a CXL value.

Compiling the code in Figure~\ref{fig:inc} results in the CXL machine code
listed in Figure~\ref{fig:inccode}.
The CXL machine is predominantly a \emph{stack machine}.
Most instructions pop values from the stack or push values onto the stack.
Initially there is one process that starts executing at instruction 0.
In this case, there is a \texttt{JUMP} instruction that sets the program
counter to 22.  At program counter 1 is the code for the \texttt{up} method.
All methods start with a \texttt{Frame} instruction and end with a \texttt{Return}
instruction.

The \texttt{Frame} instruction has three arguments:
\begin{enumerate}
\item A token containing the name of the method;
\item A token containing the name of the argument of the method;
\item A program counter of the method's \texttt{Return} instruction.
\end{enumerate}

A \emph{token} is a four-tuple containing a \emph{lexeme}, a file name, a
line number in the file, and a column number in the file.  For example,
\texttt{(’up’, ’Up.cxl’, 1, 5)} represents the lexeme \texttt{up} in
file \texttt{Up.xcl}, line 1, column 5.  Tokens make it easy to relate
the CXL machine instructions to the CXL source code.

The code generated from \texttt{count := count + 1} in line 2 of
\texttt{Up.cxl} is as follows:

\begin{enumerate} \setcounter{enumi}{1}
\item the \texttt{Constant} instruction pushes the constant 1
onto the stack of the process.
\item The \texttt{Load} instruction loads the shared variable
\texttt{count} from the shared memory and pushes its value onto the
stack.
\item \texttt{Nary} stands for \texttt{n-ary}: in this case it is a \texttt{+}
operation with 2 arguments.  It pops two values from the stack, adds them,
and pushes the result back onto the stack.
\item The \texttt{Name} instruction pushes the address of the \texttt{count}
variable onto the stack.
\item The \texttt{Store} instruction pops the address of a variable and pops
a CXL value, and updates the memory by replacing the CXL value oat the given
address with the new CXL value.
\end{enumerate}

Figure~\ref{fig:incoutput} shows the output produced by running the
\texttt{Up.cxl} program.
It starts by reporting that the assertion on line 12 failed and that
\texttt{count} has value 1 instead of 0:
\texttt{Assertion failed (’assert’, ’Up.cxl’, 12, 1) 1}.
Next it reports an execution that failed this assertion.  The output has
five columns:
\begin{enumerate}
\item The entry point of the process (\texttt{\_\_main\_\_} for the main process);
\item The tag of the process (in this case always 0);
\item The sequence of program counters of the CXL machine instructions that the process executed;
\item The current program counter of the process;
\item The contents of the shared memory.
\end{enumerate}

If we look at the middle three rows, we see that:
\begin{enumerate}
\item Process 1 executed instructions 1 through 5, loading the value of
\texttt{count} but stopping just before storing 1 into \texttt{count};
\item Process 2 executed instructions 1 through 10, storing 1 into
into \texttt{count} and storing \texttt{True} into \texttt{done[2]};
\item Process 1 continues execution, storing value 1 into \texttt{count}
and storing \texttt{True} into \texttt{done[1]}.
\end{enumerate}

This makes precise the concurrency problem that we encountered.

\chapter{Critical Sections}

Hopefully you have started thinking of how to solve the concurrency
problem and you may already have prototyped some solutions.
In this chapter we will go through a few reasonable but broken attempts.
At the heart of the problem is that we would like make sure that when
the \texttt{count} variable is being updated that no other process is
trying to do the same thing.  We call this a \emph{critical section}: a
set of instructions where only one process is allowed to execute at a
time.

\chapter{Naive Attempts at a Solution}

\begin{figure}
\begin{code}
\verbatiminput{UpLock.cxl}
\end{code}
\caption{Naive implementation of a lock.}
\label{fig:uplock}
\end{figure}

\begin{figure}
\begin{code}
\verbatiminput{UpFlags.cxl}
\end{code}
\caption{Naive use of flags to solve mutual exclusion.}
\label{fig:upflags}
\end{figure}

\begin{figure}
\begin{code}
\begin{verbatim}
==== Livelock ====
__main__ 0 [0,35-63]    64 {'flags': {2: False, 1: False}, 'count': 0,
                                'done': {2: False, 1: False}}
up       1 [1-13,21-24] 25 {'flags': {2: False, 1: True}, 'count': 0,
                                'done': {2: False, 1: False}}
\end{verbatim}
\end{code}
\caption{Error output of Figure~\ref{fig:upflags}.}
\label{fig:upflagsoutput}
\end{figure}

Figure~\ref{fig:uplock} presents a solution based on a \emph{lock}.
The idea is that the lock is a baton that at most one process can own at
a time.
Initially the lock is not owned, indicated by lock being \texttt{False}.
To enter the critical section, a process waits until lock is \texttt{False}
and then sets it to \texttt{True} to indicate that the lock has been taken.
The process then executes the critical section.  Finally the process
releases the lock by setting it back to \texttt{False}.

Unfortunately, if we run the program, we find that the assertion still
fails.  Diagnosing the problem, we see that the \texttt{lock} variable
suffers from the same problem as the \texttt{count} variable: operations
on it consist of several instructions are divisible.  It is thus possible
for both processes to believe the lock is available and obtain the lock
at the same time.

Figure~\ref{fig:upflags} presents a solution based on each process having
a flag indicating that it is trying to enter the critical section.
After setting the flag, the process waits until the other process is not
trying to enter the critical section.
If we run this program, the assertion does not fail.  In fact, this
solution does prevent both processes being in the critical section at
the same time.
However, it has a different problem called livelock: if both try to
enter the critical section at the same time, they may end up waiting for
one another.

\end{document}
