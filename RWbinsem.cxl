# split binary semaphore solution to read/write locks

import synch;

def vHat():
    if (nwritersEntered == 0) and (nreadersWaiting > 0):
        nreadersWaiting = nreadersWaiting - 1;
        call V &(rsema);
    elif ((nreadersEntered + nwritersEntered) == 0) and (nwritersWaiting > 0):
        nwritersWaiting = nwritersWaiting - 1;
        call V &(wsema);
    else:
        call V &(mutex);
    ;
;
def reader():
    while choose({ False, True }):
        call P &(mutex);
        if nwritersEntered > 0:
            nreadersWaiting = nreadersWaiting + 1;
            call vHat();
            call P &(rsema);
        ;
        nreadersEntered = nreadersEntered + 1;
        call vHat();

        @rcs: assert atLabel.wcs == dict{};

        call P &(mutex);
        nreadersEntered = nreadersEntered - 1;
        call vHat();
    ;
;
def writer():
    while choose({ False, True }):
        call P &(mutex);
        if (nreadersEntered + nwritersEntered) > 0:
            nwritersWaiting = nwritersWaiting + 1;
            call vHat();
            call P &(wsema);
        ;
        nwritersEntered = nwritersEntered + 1;
        call vHat();

        @wcs: assert (atLabel.wcs == dict{ nametag(): 1 }) and
                     (atLabel.rcs == dict{})
              ;

        call P &(mutex);
        nwritersEntered = nwritersEntered - 1;
        call vHat();
    ;
;
mutex = Semaphore(1);
rsema = Semaphore(0);
wsema = Semaphore(0);
nreadersEntered = 0;
nreadersWaiting = 0;
nwritersEntered = 0;
nwritersWaiting = 0;

spawn reader();
spawn reader();
spawn writer();
spawn writer();
