from synch import Lock, acquire, release
from alloc import malloc, free

def Queue():
    result = { 
        .size: 0,
        .head: None, 
        .tail: None, 
        .lock: Lock() 
    }

def assert_invariants(q):
    pass
    if q->head == None:
        assert q->tail == None
    else:
        let (count, node, encountered) = (1, q->head, {}):
            while node->next != None:
                assert len(encountered & { node }) == 0
                encountered = encountered | { node }
                node = node->next
                count += 1
            assert node == q->tail, [node, q->tail, !q]
            assert count == q->size, [count, q->size, !q]

def put(q, v):
    let node = malloc({ .value: v, .next: None }):
        acquire(?q->lock)

        if q->head == None:
            q->head = q->tail = node
        else:
            q->tail->next = node
            q->tail = node
    
        q->size += 1

        assert_invariants(q)

        release(?q->lock)
    
def get(q):
    acquire(?q->lock)

    let node = q->head:
        if node == None:
            result = None
        else:
            result = node->value
            q->head = node->next
            if q->head == None:
                q->tail = None
            free(node)

            q->size -= 1

    assert_invariants(q)

    release(?q->lock)

def qsize(q):
    acquire(?q->lock)
    result = q->size
    release(?q->lock)

def contains(q, v):
    acquire(?q->lock)

    result = False

    let node = q->head:
        while node != None:
            if node->value == v:
                result = True
            
            node = node->next

    assert_invariants(q)

    release(?q->lock)

def insert(q, v):
    acquire(?q->lock)

    let node = malloc({ .value: v, .next: None }):
        if q->head == None:
            q->head = q->tail = node
        else:
            node->next = q->head
            q->head = node
                        
        q->size += 1

    assert_invariants(q)

    release(?q->lock)

def remove(q, v):
    acquire(?q->lock)

    let (node, prev) = (q->head, None):
        while node != None:
            if node->value == v:
                node_to_free = node

                if prev != None:
                    if node == q->tail:
                        q->tail = prev

                    node = node->next
                    prev->next = node
                else:
                    node = node->next
                    q->head = node
                    if node == None:
                        q->tail = None  

                free(node_to_free)
        
                q->size -= 1

            else:
                prev = node
                node = node->next

            assert_invariants(q)

    release(?q->lock)
