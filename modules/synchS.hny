import list;

def Lock():
    result = dict{ .locked: False, .suspended: [] };
;
def lock(lk):
    atomic:
        if lk->locked:
            stop lk->suspended;     # wait in the hall
            assert lk->locked;
        else:
            lk->locked = True;      # enter the bathroom
        ;
    ;
;
def unlock(lk):
    atomic:
        if lk->suspended == []:
            lk->locked = False;     # leave the bathroom
        else:
            # while leaving bathroom, let somebody from the hall into the bathroom
            go (head(lk->suspended)) ();
            lk->suspended = tail(lk->suspended);
        ;
    ;
;
def Condition(lk):
    result = dict{ .lock: lk, .waiters: [] };
;
def wait(c):
    atomic:
        unlock(c->lock);    # leave bathroom
        stop c->waiters;    # enter bedroom
    ;
;
def notify(c):
    atomic:
        let lk, waiters = c->lock, c->waiters:
            if waiters != []:
                # move somebody from the bedroom to the hall
                lk->suspended += [head(waiters),];
                c->waiters = tail(waiters);
            ;
        ;
    ;
;
def notifyAll(c):
    atomic:
        # move everybody in the bedroom to the hall
        let lk, waiters = c->lock, c->waiters:
            lk->suspended += waiters;
            c->waiters = [];
        ;
    ;
;
def Semaphore(cnt):
    result = dict{ .count: cnt, .waiters: [] };
;
def P(sema):
    atomic:
        if (!sema).count > 0:
            (!sema).count -= 1;
        else:
            stop (!sema).waiters;
        ;
    ;
;
def V(sema):
    atomic:
        let cnt, waiters = (!sema).count, (!sema).waiters:
            if waiters != []:
                assert cnt == 0;
                go (waiters[0]) ();
                (!sema).waiters = tail(waiters);
            else:
                (!sema).count = cnt + 1;
            ;
        ;
    ;
;
def Queue():
    result = dict{ list: [], waiters: [] };
;
def dequeue(q):
    atomic:
        let list = q->list:
            if list == []:
                stop q->waiters;
            ;
            result = head(list);
            q->list = tail(list);
        ;
    ;
;
def enqueue(q, item):
    atomic:
        q->list = append(q->list, item);
        let waiters = q->waiters:
            if waiters != []:
                go (waiters[0]) item;
                q->waiters = tail(waiters);
            ;
        ;
    ;
;
