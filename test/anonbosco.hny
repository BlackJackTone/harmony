import synch, bag, list

const F = 1
const N = (3 * F) + 1
const NROUNDS = 3

sequential network

network = bag.empty()
decisions = {}

def broadcast(msg):
    atomic:
        bag.add(?network, msg)

def process(proposal):
    let est = proposal:
        for round in {0..NROUNDS-1}:
            # Broadcast estimate
            broadcast(round, est)

            # Wait until there are enough messages in the current round
            let received = [0, 0]:
                while list.sum(received) < (N - F):
                    let count = [0, 0]:
                        atomic:
                            for msg in keys(network):
                                let (r, e) = msg:
                                    if r == round:
                                        count[e] = network[msg]
                        if count != received:
                            let cands = { i for i in {0, 1} where count[i] > received[i] }:
                                received[choose(cands)] += 1

                # Update estimate
                assert(received[0] != received[1])
                est = 0 if received[0] < received[1] else 1
                if received[est] == (N - F):
                    atomic:
                        decisions |= { est }
                        assert len(decisions) <= 1

let nzeroes = choose({0..N/2}):
    for i in {0..N-1}:
        spawn process(0 if i < nzeroes else 1)
