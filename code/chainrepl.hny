import list
import action

const NREPLICAS = 3
const NOPS = 2

# Global state
replicas = [{
    .crashed: False,
    .requests: {},
    .hist: [],
    .config: {0..NREPLICAS-1},
    .received: {},
    .delivered: 0 },] * NREPLICAS
clients = [ False, ] * NOPS

const is_head = lambda(p): p == min(replicas[p].config) end
const is_tail = lambda(p): p == max(replicas[p].config) end

def is_successor(self, p) returns result:
    let succ = { q for q in replicas[self].config where q > self }:
        result = False if succ == {} else (p == min(succ))

def do_sendOperation(client):
    print(client + 1)
    clients[client] = True
    for p in {0..NREPLICAS-1}:
        replicas[p].requests |= { client }

const sendOperation = lambda(): { (do_sendOperation, client)
    for client in {0..NOPS-1} where not clients[client]
  } end

def do_gotOperation(self, op):
    replicas[self].hist += [op,]

const gotOperation = lambda(): { (do_gotOperation, (p, op))
    for p in {0..NREPLICAS-1}
      where not replicas[p].crashed and is_head(p)
    for op in replicas[p].requests
      where op not in replicas[p].hist } end

def do_sendHist(self, p):
    replicas[p].received |= { replicas[self].hist }

const sendHist = lambda(): { (do_sendHist, (p, q))
    for p in {0..NREPLICAS-1}
      where not replicas[p].crashed
    for q in {0..NREPLICAS-1}
      where is_successor(p, q) and (replicas[p].hist not in replicas[q].received)
  } end

def do_gotHist(self, hist):
    replicas[self].hist = hist

const gotHist = lambda(): { (do_gotHist, (p, hist))
    for p in {0..NREPLICAS-1}
      where not replicas[p].crashed
    for hist in replicas[p].received
      where (len(replicas[p].hist) < len(hist)) and list.startswith(hist, replicas[p].hist) } end

def do_Deliver(self):
    print(self+1, replicas[self].hist[replicas[self].delivered] + 1)
    replicas[self].delivered += 1

const deliver = lambda(): { (do_Deliver, p)
    for p in {0..NREPLICAS-1}
      where not replicas[p].crashed and is_tail(p) and (len(replicas[p].hist) > replicas[p].delivered) } end

def do_crash(self):
    replicas[self].crashed = True

# Only live processors can crash, but only if there are more than one.
def crash():
    result = { (do_crash, p)
        for p in {0..NREPLICAS-1} where not replicas[p].crashed and
            not all(replicas[q].crashed
                for q in {0..NREPLICAS-1} where (q != p)) }

def do_detect(self, p):
    replicas[self].config -= { p }

const detect = lambda(): { (do_detect, (p, q))
    for p in {0..NREPLICAS-1} where not replicas[p].crashed
    for q in {0..NREPLICAS-1} where replicas[q].crashed and
                (q in replicas[p].config) } end

action.explore({sendOperation, gotOperation, sendHist, gotHist, deliver, crash, detect})
