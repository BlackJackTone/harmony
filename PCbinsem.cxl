# split binary semaphore solution to producer/consumer bounded buffer

import synch;

const N = 2;         # size of bounded buffer

def vHat():
    if (cnt < N) and (pwaiting > 0):
        pwaiting = pwaiting - 1;
        call V&(psema);
    elif (cnt > 0) and (cwaiting > 0):
        cwaiting = cwaiting - 1;
        call V&(csema);
    else:
        call V&(mutex);
    ;
;
def produce(item):
    call P&(mutex);
    if cnt == N:
        pwaiting = pwaiting + 1;
        call vHat();
        call P&(psema);
    ;
    # buf[myin] = choose({ 10, 20 });
    buf[myin] = item;
    myin = (myin % N) + 1;
    cnt = cnt + 1;
    call vHat();
;
def consume(self):
    call P&(mutex);
    if cnt == 0:
        cwaiting = cwaiting + 1;
        call vHat();
        call P&(csema);
    ;
    self = buf[myout];
    myout = (myout % N) + 1;
    cnt = cnt - 1;
    call vHat();
;
def producer():
    while True:
        # var item = choose({ 10, 20 });
        var item = 1;
        @before_produce:
        call produce(item);
        @after_produce: pass;
    ;
;
def consumer():
    while True:
        @before_consume:
        var item = consume();
        @after_consume: pass;
    ;
;
buf = dict{ 0 for x in 1..N };
cnt = 0;
myin = 1;
myout = 1;
pwaiting = 0;
cwaiting = 0;
mutex = Semaphore(1);
psema = Semaphore(0);
csema = Semaphore(0);

atomic:
    spawn producer(), 0;
    spawn producer(), 0;
    spawn consumer(), 1;
    spawn consumer(), 1;
;
