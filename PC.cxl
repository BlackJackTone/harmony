const N = 2;         # size of bounded buffer

def tas(self):
    atomic:
        var oldval = ^self;
        ^self := True;
        self := oldval;
    ;
;
def lock():
    while tas&(mylock):
        pass;
    ;
;
def unlock():
    mylock := False;
;
def producer():
    while True:
        var full = True;
        while full:
            call lock();
            if cnt < N:
                full := False;
            else:
                assert cnt == N, cnt;
                call unlock();
            ;
        ;
        @room:
            cnt := cnt + 1;
            buf[myin] := choose({ 10, 20 });
            myin := (myin % N) + 1;
        @produced:

        call unlock();
    ;
;
def consumer():
    while True:
        var empty = True;
        while empty:
            call lock();
            if cnt > 0:
                empty := False;
            else:
                assert cnt == 0, cnt;
                call unlock();
            ;
        ;
        @avail:
            cnt := cnt - 1;
            # self := buf[myout];
            myout := (myout % N) + 1;
        @consumed:

        call unlock();
    ;
;
buf := dict{ 0 for x in 1..N };
myin := 1;
myout := 1;
cnt := 0;
mylock := False;

spawn producer(), 0;
spawn producer(), 0;
spawn producer(), 0;
spawn consumer(), 1;
spawn consumer(), 1;
