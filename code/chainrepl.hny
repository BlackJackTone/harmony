import list
import action

const N = 3
const VALUES = { "a", "b" }

# Global state: initially each process is "fetal"
procs = [{ .mode: "fetal", .log: [], .detected: {}, .received: {} },] * N

# Every live processor knows about every other live processor
invariant all(("add_proc", p) in procs[q].log
                    for p in {0..N-1} where procs[p].mode == "live"
                    for q in {0..N-1} where procs[q].mode == "live")

# If p appears before q in q's log, then q's log is a prefix of p's
invariant all((list.index(procs[q].log, ("add_proc", p)) <
                list.index(procs[q].log, ("add_proc", q))) =>
                        list.startswith(procs[p].log, procs[q].log)
                    for p in {0..N-1} where procs[p].mode == "live"
                    for q in {0..N-1} where procs[q].mode == "live")

# get_conf(p) returns the configuration according to process p
const get_conf = lambda(p): [ q for (t, q) in procs[p].log
    where (t == "add_proc") and (q not in procs[p].detected) ] end

# is_head(p) returns whether process p thinks it's the head
const is_head = lambda(p): get_conf(p)[0] == p end

# is_successor(self, p) returns whether self thinks p is its successor
def is_successor(self, p):
    let conf = get_conf(self)
    let me = list.index(conf, self):
        result = (me < (len(conf) - 1)) and (p == conf[me + 1])

def do_start(self):
    procs[self].mode = "live"
    procs[self].log = [ ("add_proc", self), ]

const start = lambda(): { (do_start, 0) } \
    if all(procs[p].mode == "fetal" for p in {0..N-1}) else {} end

def do_gotClientUpdate(self, v):
    procs[self].log += [("clt_update", v),]

const gotClientUpdate = lambda(): { (do_gotClientUpdate, (p, v))
    for p in {0..N-1}
      where (procs[p].mode == "live") and is_head(p)
    for v in VALUES
      where ("clt_update", v) not in procs[p].log } end

def do_gotJoinRequest(self, p):
    procs[self].log += [("add_proc", p),]

const gotJoinRequest = lambda(): { (do_gotJoinRequest, (p, q))
    for p in {0..N-1}
      where (procs[p].mode == "live") and is_head(p)
        for q in {0..N-1}
          where ("add_proc", q) not in procs[p].log } end

def do_sendLog(self, p):
    procs[p].received |= { procs[self].log }

const sendLog = lambda(): { (do_sendLog, (p, q))
    for p in {0..N-1}
      where (procs[p].mode == "live") and is_head(p)
    for q in {0..N-1}
      where is_successor(p, q) and (procs[p].log not in procs[q].received)
  } end

def do_gotLog(self, log):
    procs[self].mode = "live"
    procs[self].log = log

const gotLog = lambda(): { (do_gotLog, (p, log))
    for p in {0..N-1}
      where (procs[p].mode in { "fetal", "live" })
    for log in procs[p].received
      where (len(procs[p].log) < len(log)) and list.startswith(log, procs[p].log) } end

def do_crash(self):
    procs[self].mode = "crashed"

const crash = lambda(): { (do_crash, p)
    for p in {0..N-1} where (procs[p].mode == "live") and
        not all(procs[q].mode != "live"
            for q in {0..N-1} where (q != p)) } end

def do_detect(self, p):
    procs[self].detected |= { p }

const detect = lambda(): { (do_detect, (p, q))
    for p in {0..N-1} where procs[p].mode == "live"
    for q in {0..N-1} where (procs[q].mode == "crashed") and
                (q not in procs[p].detected) } end

action.explore({start, gotClientUpdate, gotJoinRequest,
                    sendLog, gotLog, crash, detect})
