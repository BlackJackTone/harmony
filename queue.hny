from synch import Lock, acquire, release
from alloc import malloc, free

def Queue():
    result = { .head: None, .tail: None, .size: 0, .lock: Lock() }

def put(q, v):
    let node = malloc({ .value: v, .next: None }):
        acquire(?q->lock)
        if q->head == None:
            q->head = q->tail = node
        else:
            q->tail->next = node
            q->tail = node
        q->size += 1
        release(?q->lock)
    
def get(q):
    acquire(?q->lock)
    let node = q->head:
        if node == None:
            result = None
        else:
            result = node->value
            q->head = node->next
            if q->head == None:
                q->tail = None
            free(node)
            q->size -= 1
    release(?q->lock)

def qsize(q):
    acquire(?q->lock)
    result = q->size
    release(?q->lock)

def contains(q, v):
    acquire(?q->lock)
    result = False
    let curr_node = q->head:
        while(curr_node != None):    
            if curr_node->value == v:
                result = True
            curr_node = curr_node->next
    release(?q->lock)

def insert(q, v):
    acquire(?q->lock)
    let node = malloc({ .value: v, .next: q->head }):
        if q->head == None:
            q->head = node
            q->tail = node
        else:
            q->head = node
        q->size += 1
    release(?q->lock)

def remove(q, v):
    acquire(?q->lock)
    remove_q = Queue
    let curr_node = q->head:
        let prev_node = None:    
            while(curr_node != None):
                if curr_node->value == v:
                    if prev_node != None:
                        prev_node->next = curr_node->next
                    else:
                        q->head = q->head->next
                    save_next = curr_node->next
                    put(?remove_q, curr_node)
                    curr_node = save_next
                    q->size -= 1
                else:
                    prev_node = curr_node
                    curr_node = curr_node->next
    let curr_node = remove_q->head:
        while curr_node != None:
            save_next = curr_node->next
            free(curr_node)
            curr_node = save_next
    release(?q->lock)