import bag

const F = 1
const NSERVERS = (2 * F) + 1
const NWRITERS = 1
const NREADERS = 2

network = bag.empty()

def send(m):
    atomic: network = bag.add(network, m)

def server():
    let t, v, received = (0, None), None, {}:
        while True:
            select m in { m for m in keys network - received where m.type in {.read, .write} }:
                received |= { m }
                if (m.type == .write) and (m.value[0] > t):
                    t, v = m.value
                send({ .type: .response, .dst: m.src, .value: (t, v) })

def receive(self, phase):
    let msgs = { m:c for m:c in network
                where (m.type == .response) and (m.dst == (self, phase)) }:
        result = bag.combinations(msgs, NSERVERS - F)

def read(self):
    send({ .type: .read, .src: (self, 1) })
    select msgs in receive(self, 1):
        result = max(m.value for m in keys msgs)
        send({ .type: .write, .src: (self, 2), .value: result })
    select msgs in receive(self, 2):
        pass

def write(self, v):
    send({ .type: .read, .src: (self, 1) })
    select msgs in receive(self, 1):
        result = max(m.value for m in keys msgs)
        let t = (result[0][0] + 1, self):
            send({ .type: .write, .src: (self, 2), .value: (t, v) })
    select msgs in receive(self, 2):
        pass

for i in { 1 .. NSERVERS }:
    spawn eternal server()
for i in { 1 .. NWRITERS }:
    spawn write((.writer, i), (.writer, i))
for i in { 1 .. NREADERS }:
    spawn read((.reader, i))
