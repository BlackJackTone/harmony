import list

const NBANKS = 3
const NCOORDS = 2
const MAX_BALANCE = 2
const MAX_TRANSFER = 2

balances = [ choose({ 0 .. MAX_BALANCE }) for i in { 0 .. NBANKS - 1 } ]
total = list.sum(balances)

network = {}

def send(m):
    atomic: network |= { m }

def bank(self, balance):
    let status = .idle let received = {}:
        while True:
            select req in { req for req in network - received where req.dst == self }:
                received |= { req }
                if req.request == .withdraw:
                    if (status != .idle) or (req.amount > balance):
                        send({ .dst: req.src, .src: self, .response: .no, .balance: balance })
                    else:
                        status = (.busy, req.src, balance)
                        balance -= req.amount
                        send({ .dst: req.src, .src: self, .response: .yes, .balance: balance })
                elif req.request == .deposit:
                    if status != .idle:
                        send({ .dst: req.src, .src: self, .response: .no, .balance: balance })
                    else:
                        status = (.busy, req.src, balance)
                        balance += req.amount
                        send({ .dst: req.src, .src: self, .response: .yes, .balance: balance })
                elif req.request == .commit:
                    assert status != .idle
                    assert status[1] == req.src
                    status = .idle
                else:
                    assert status != .idle
                    assert status[1] == req.src
                    assert req.request == .abort
                    balance = status[2]
                    status = .idle

def receive(self, sources):
    let forme = { m for m in network where m.dst == self }:
        if { m.src for m in forme } == sources:
            result = { forme }
        else:
            result = {}

def check(self):
    let allbanks = { (.bank, i) for i in { 0 .. NBANKS - 1 } }:
        for bank in allbanks:
            send({ .dst: bank, .src: self, .request: .withdraw, .amount: 0 })
        select msgs in receive(self, allbanks):
            if all(m.response == .yes for m in msgs):
                assert list.sum(m.balance for m in msgs) == total
            for m in msgs where m.response == .yes:
                send({ .dst: m.src, .src: self, .request: .abort })

def transfer(self):
    let src = choose({ (.bank, i) for i in { 0 .. NBANKS - 1 }})
    let dst = choose({ (.bank, i) for i in { 0 .. NBANKS - 1 }} - { src })
    let amount = choose({1 .. MAX_TRANSFER }):
        send({ .dst: src, .src: self, .request: .withdraw, .amount: amount })
        send({ .dst: dst, .src: self, .request: .deposit, .amount: amount })
        select msgs in receive(self, { src, dst }):
            if all(m.response == .yes for m in msgs):
                for m in msgs where m.response == .yes:
                    send({ .dst: m.src, .src: self, .request: .commit })
            else:
                for m in msgs where m.response == .yes:
                    send({ .dst: m.src, .src: self, .request: .abort })

for i in { 0 .. NBANKS - 1 }:
    spawn eternal bank((.bank, i), balances[i])
for i in { 1 .. NCOORDS }:
    if choose({ .transfer, .check }) == .transfer:
        spawn transfer((.coord, i))
    else:
        spawn check((.coord, i))
