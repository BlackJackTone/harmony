const NBANKS = 3
const NCOORDS = 2
const MAX_BALANCE = 1

network = {}

def send(m):
    atomic: network |= { m }

def bank(self, balance):
    let status, received = (), {}:
        while True:
            select req in { req for req in network - received where req.dst == self }:
                received |= { req }
                if req.request == .withdraw:
                    if (status != ()) or (req.amount > balance):
                        send({ .dst: req.src, .src: self, .response: .no })
                    else:
                        status = balance
                        balance -= req.amount
                        send({ .dst: req.src, .src: self, .response: .yes, .funds: balance })
                elif req.request == .deposit:
                    if status != ():
                        send({ .dst: req.src, .src: self, .response: .no })
                    else:
                        status = balance
                        balance += req.amount
                        send({ .dst: req.src, .src: self, .response: .yes, .funds: balance })
                elif req.request == .commit:
                    assert status != ()
                    status = ()
                else:
                    assert (status != ()) and (req.request == .abort)
                    balance, status = status, ()

import list

def receive(self, sources):
    let forme = { m for m in network where m.dst == self }:
        result = { forme } if { m.src for m in forme } == sources else {}

def transfer(self, b1, b2, amt):
    send({ .dst: b1, .src: self, .request: .withdraw, .amount: amt })
    send({ .dst: b2, .src: self, .request: .deposit, .amount: amt })
    select msgs in receive(self, { b1, b2 }):
        if all(m.response == .yes for m in msgs):
            possibly True
            for m in msgs where m.response == .yes:
                send({ .dst: m.src, .src: self, .request: .commit })
        else:
            for m in msgs where m.response == .yes:
                send({ .dst: m.src, .src: self, .request: .abort })

def check(self, total):
    let allbanks = { (.bank, i) for i in { 1 .. NBANKS } }:
        for bank in allbanks:
            send({ .dst: bank, .src: self, .request: .withdraw, .amount: 0 })
        select msgs in receive(self, allbanks):
            possibly all(m.response == .yes for m in msgs)
            assert all(m.response == .yes for m in msgs) =>
                        (list.sum(m.funds for m in msgs) == total)
            for m in msgs where m.response == .yes:
                possibly True
                send({ .dst: m.src, .src: self, .request: .abort })

let balances = { i:choose({ 0 .. MAX_BALANCE }) for i in { 1 .. NBANKS } }:
    for i in { 1 .. NBANKS }:
        spawn eternal bank((.bank, i), balances[i])
    for i in { 1 .. NCOORDS }:
        if choose({ .transfer, .check }) == .transfer:
            let b1 = choose({ (.bank, j) for j in { 1 .. NBANKS }})
            let b2 = choose({ (.bank, j) for j in { 1 .. NBANKS }} - { b1 }):
                spawn transfer((.coord, i), b1, b2, 1)
        else:
            spawn check((.coord, i), list.sum(balances))
