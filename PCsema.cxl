# counting semaphore solution to producer/consumer bounded buffer

import synch;

const NSLOTS = 1;         # size of bounded buffer
const NITEMS = 3;         # number of items to produce/consume

def produce(item):
    call P&(nempty);
    call P&(mutex);
    # buf[myin] = choose({ 10, 20 });
    buf[myin] = item;
    myin = (myin % NSLOTS) + 1;
    call V&(mutex);
    call V&(nfull);
;
def consume():
    call P&(nfull);
    call P&(mutex);
    result = buf[myout];
    myout = (myout % NSLOTS) + 1;
    call V&(mutex);
    call V&(nempty);
;
def producer():
    let producing = True, item = ():
        while producing:
            call lock &(producelock);
            if nproduced == NITEMS:
                producing = False;
                call unlock &(producelock);
            else:
                item = nproduced;
                nproduced = nproduced + 1;
                call unlock &(producelock);
                call produce(item);
            ;
        ;
    ;
;
def consumer():
    let consuming = True, item = ():
        while consuming:
            call lock &(consumelock);
            if nconsumed == NITEMS:
                consuming = False;
                call unlock &(consumelock);
            else:
                nconsumed = nconsumed + 1;
                call unlock &(consumelock);
                item = consume();
            ;
        ;
    ;
;
buf = dict{ 0 for x in 1..NSLOTS };
myin = 1;
myout = 1;
nfull = Semaphore(0);
nempty = Semaphore(NSLOTS);
mutex = Semaphore(1);

nproduced = 0;
nconsumed = 0;
producelock = Lock();
consumelock = Lock();

atomic:
    spawn producer(), ();
    spawn producer(), ();
    spawn consumer(), ();
    spawn consumer(), ();
;
