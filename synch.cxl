def tas(lk):
    atomic:
        result = ^lk;
        ^lk = True;
    ;
;
def Lock():
    result = False;
;
def lock(lk):
    while tas(lk):
        pass;
    ;
;
def unlock(lk):
    ^lk = False;
;
def Condition(lk):
    result = dict{ .lock: lk, .waiters: {} };
;
def wait(c):
    var pid = getpid();
    (*
        var cond = ^c;
        var lk = cond.lock;
        (^c).waiters = cond.waiters + { pid };
    *)
    var lk = (^c).lock;
    (^c).waiters = (^c).waiters + { pid };
    ^lk = False;
    var blocked = True;
    while blocked:
        atomic:
            if not (^lk):
                if not(pid in (^c).waiters):
                    ^lk = True;
                    blocked = False;
                ;
            ;
        ;
    ;
;
def notify(c):
    var waiters = (^c).waiters;
    if waiters != {}:
        var pid = choose(waiters);
        (^c).waiters = waiters - { pid };
    ;
;
def notifyAll(c):
    (^c).waiters = {};
;
def Semaphore(cnt):
    result = cnt;
;
def P(sema):
    var blocked = True;
    while blocked:
        atomic:
            if (^sema) > 0:
                ^sema = (^sema) - 1;
                blocked = False;
            ;
        ;
    ;
;
def V(sema):
    atomic:
        ^sema = (^sema) + 1;
    ;
;
