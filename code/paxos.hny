import bag

const F = 1
const NACCEPTORS = (2 * F) + 1
const NLEADERS = F + 1
const NBALLOTS = 2

network = bag.empty()
decisions = {}

def send(m):
    atomic: bag.add(?network, m)

def receive(ballot, phase):
    let msgs = { (b,p,t,e):c for (b,p,t,e):c in network
                        where (b,p,t) == (ballot, phase, .B) }:
        result = bag.combinations(msgs, NACCEPTORS - F)

def leader(ballot, proposal):
    send(ballot, 1, .A, None)

    while ballot <= NBALLOTS:
        select quorum in receive(ballot, 1):
            let accepted = { e for (b,p,t,e) in keys(quorum) where e != None }:
                if accepted != {}:
                    _, proposal = max(accepted)
            send(ballot, 2, .A, proposal)
        select quorum in receive(ballot, 2):
            if bag.count(quorum, (ballot, 2, .B, (ballot, proposal))) == (NACCEPTORS - F):
                decisions |= { proposal }
                assert len(decisions) <= 1
            ballot += NLEADERS
            if ballot <= NBALLOTS:
                send(ballot, 1, .A, None)

def acceptor():
    let ballot = 0 let last_accepted = None let received = {}:
        while len(received) < (NBALLOTS * 2):
            select b,p,t,e in { (b,p,t,e) for b,p,t,e:c in network
                        where ((b,p) not in received) and (t == .A) }:
                received |= { (b, p) }
                if b >= ballot:
                    ballot = b
                    if p == 2:
                        last_accepted = (ballot, e)
                send(b, p, .B, last_accepted)

let nzeroes = choose({0..NLEADERS/2}):
    for i in {1..NLEADERS}:
        spawn leader(i, i <= nzeroes)
for i in {1..NACCEPTORS}:
    spawn acceptor()
