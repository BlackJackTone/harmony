import synch;

const N = 2;         # size of bounded buffer

def produce(item):
    call P&(nempty);
    call P&(mylock);
    # buf[myin] = choose({ 10, 20 });
    buf[myin] = item;
    myin = (myin % N) + 1;
    call V&(mylock);
    call V&(nfull);
;
def consume(self):
    call P&(nfull);
    call P&(mylock);
    self = buf[myout];
    myout = (myout % N) + 1;
    call V&(mylock);
    call V&(nempty);
;
def producer():
    while True:
        # var item = choose({ 10, 20 });
        var item = 1;
        @before_produce:
        call produce(item);
        @after_produce: pass;
    ;
;
def consumer():
    while True:
        @before_consume:
        var item = consume();
        @after_consume: pass;
    ;
;
buf = dict{ 0 for x in 1..N };
myin = 1;
myout = 1;
nfull = Semaphore(0);
nempty = Semaphore(N);
mylock = Semaphore(1);

atomic:
    spawn producer(), 0;
    spawn producer(), 0;
    spawn consumer(), 1;
    spawn consumer(), 1;
;
