const N = 2;         # size of bounded buffer

def tas(self):
    atomic:
        var oldval = ^self;
        ^self := True;
        self := oldval;
    .
.

def lock(lk):
    while tas(lk): pass.
.

def unlock(lk):
    ^lk := False;
.

def produce(item):
    var full = True;
    while full:
        call lock &(mylock);
        if cnt < N:
            full := False;
        else:
            assert cnt == N, cnt;
            call unlock &(mylock);
        .
    .
    @room:
        cnt := cnt + 1;
        # buf[myin] := choose({ 10, 20 });
        buf[myin] := item;
        myin := (myin + 1) % N;

    call unlock &(mylock);
.

def consume(self):
    var empty = True;
    while empty:
        call lock &(mylock);
        if cnt > 0:
            empty := False;
        else:
            assert cnt == 0, cnt;
            call unlock &(mylock);
        .
    .
    @avail:
        cnt := cnt - 1;
        self := buf[myout];
        myout := (myout + 1) % N;

    call unlock &(mylock);
.
def producer():
    while True:
        call produce[choose({ 10, 20 })];
    .
.
def consumer():
    while True:
        call consume();
    .
.
buf := dict{ x:0 | x in 0..(N-1) };
myin := 0;
myout := 0;
cnt := 0;
mylock := False;

spawn producer(), 0;
spawn producer(), 0;
spawn consumer(), 1;
spawn consumer(), 1;
