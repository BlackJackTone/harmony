\documentclass[twocolumn]{article}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{framed}
\usepackage{tcolorbox}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{comment}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{etoolbox}
\usepackage{paralist}
% \usepackage{bold-extra}
\usepackage{xcolor}
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=violet]{hyperref}

% \renewcommand{\topfraction}{.99}
% \renewcommand{\bottomfraction}{.99}
% \renewcommand{\textfraction}{.01}
% \renewcommand{\floatpagefraction}{.9}
% \renewcommand{\dbltopfraction}{.99}
% \renewcommand{\dblfloatpagefraction}{.9}

\widowpenalty 10000
\clubpenalty 10000
\tolerance=9999
\newcommand{\tm}{\raisebox{.9ex}{\tiny tm}}

\newcommand{\harmonysource}[1]{
\begin{tabbing}
XX\=XXX\=XXX\kill
    \input{sources/#1.tex}
\end{tabbing}
}

\newcommand{\harmonylink}[1]{%
[\href{https://harmony.cs.cornell.edu/#1}{\underline{#1}}]%
}

\newcommand{\harmonyref}[2]{%
\href{https://harmony.cs.cornell.edu/output/#1}{\underline{#2}}%
}

\newenvironment{code}{
\tcolorbox
}{
\endtcolorbox
}

\title{Concurrent Programming in Harmony}
\author{Robbert van Renesse \and William Ma \and Kevin Sun \and Anthony Yang}

\begin{document}
\maketitle

<{:const:tas}>
<{:const:cas}>
<{:const:BinSem}>
<{:const:Semaphore}>
<{:const:__init__}>
<{:const:p}>
<{:const:hello}>

\begin{figure*}
\begin{center}
\includegraphics[width=.9\textwidth]{hello.pdf}
\end{center}
\caption{A selection of Harmony programs and their outputs}
\label{fig:helloworld}
\end{figure*}

\section{Introduction}

\emph{Harmony} is a Python-like programming language designed to teach
concurrent and distributed programming to students who do not have a
background in formal methods.  Harmony programs are model checked.
Without any special annotation, Harmony can diagnose a large variety
of problems:
\begin{compactitem}
\item ``Silly errors'': accessing non-existent variables,
divide-by-zero, out-of-bounds array access, trying to multiply two lists
with one another, and many more.
\item Safety violations due to assertions failing, such as an assertion to ensure mutual exclusion.
\item Liveness violations (deadlock).
\item Faulty behaviors: implementation has behaviors not seen with specification, such as violations of linearizability~\cite{HW90}.
\item Incomplete behaviors: specification has behaviors not seen with implementation, such as multiple readers not able to get a reader/writer lock simultaneously.
\item Data races: variables accessed without a lock.
\item Busy Waiting: waiting for a condition without blocking.
\end{compactitem}

Harmony programs have three sources of non-determinism:
<{choose}> operations that select a value from a set,
\emph{interleaving} due to multi-threading, and \emph{interrupts}.
\autoref{fig:helloworld} demonstrates the <{choose}> and the <{spawn}>
statements.  Since Harmony programs are model-checked and multiple
executions are explored across a finite set of states, the output of a
Harmony program is a finite automaton that describes all possible
outputs of the program.  Groups of statements can be made atomic
using the <{atomically}> keyword.  Finally, Harmony supports a thread
waiting until some condition is reached with the <{when}> statement.

Harmony programs compile to a virtual machine.  The Harmony virtual
machine is formally specified using TLA+, allowing Harmony programs
to run using TLC, the model checker that comes with the TLA+
toolbox.  Harmony has its own custom concurrent model checker that
scales significantly better for Harmony programs.

The Harmony language can be used both to \emph{specify} desired
behaviors and to \emph{implement} them.  To check that the implementation
satisfies the specification, the programmer writes a test program that
systematically checks available operations and prints the results.
The test program is first run against the specification, generating
a \emph{behavior automaton}.  The same test program is then run
against the implementation, along with the behavior automaton.
The Harmony model checker generates the product of the test program
and the behavior automaton to find discrepancies in the implementation
with respect to its specification.

Harmony has been used to verify the correctness of various lock
implementations, monitors and condition variables (both Hoare and Mesa),
various implementations of concurrent data structures including lock-free
ones, and barrier synchronization implementations.  Harmony has also been
used to verify a variety of distributed algorithms such as two-phase
commit, chain replication, various consensus algorithms such as Paxos,
and the Needham-Schroeder authentication protocols.

\begin{figure}
\begin{tabular}{|l|l|}
\hline
Boolean & <{False}>, <{True}> \\
\hline
Integer & <{..., -2, -1, 0, 1, 2, ...}> \\
\hline
String & <{"example"}>, <{.example}> \\
\hline
PC & (program counters) \\
\hline
Dictionary & <{{ .acct: 12345, .valid: False }}> \\
\hline
Set & <{{}, { 1, 2, 3 }, { False, .id, 3 }}> \\
\hline
Address & <{?lock, ?flags[2], None}> \\
\hline
Context & (generated by <{stop}> expression) \\
\hline
\end{tabular}
\caption{Harmony values}
\label{fig:values}
\end{figure}

\section{Harmony Virtual Machine}

The Harmony Virtual Machine (HVM) is fully specified in approximately
1000 lines of TLA+.
Below we summarize its most important aspects.

\subsection{Values}

Harmony has 8 types of values listed in \autoref{fig:values}.
There are no exceptions: a set can contain dictionaries, a dictionary
can map dictionaries to dictionaries, and so on.  Unlike many
object-oriented programming languages, the programmer never
has to specify what it means for two values to be the same of what its
hash value is.

Any two values can be compared using the standard comparison operators.
If two values have different types, then their order is defined as in
\autoref{fig:values} (e.g., <{False < 0}>).
For two values of the same type, Harmony defines a deterministic order.
For example, for two sets, the values in the sets are first ordered and
then lexicographically compared, so that <{{ 1, 2 } < { 1, 3 }}>.
(Note that, unlike Python, the $<$ operator is a total order and
$<$ on sets does not represent the subset relationship.)
Dictionaries are lexicographically ordered by their (key, value) pairs.

The strings <{"example"}> and <{.example}> are the same---the latter
form is convenient for use in dictionaries.
An \emph{address} represents a path in a hierarchy of dictionaries, with
<{None}> being the empty path.
Examples of \emph{program counters} include method constants and program labels.
A \emph{context} represents the state of a thread.  It includes a program
counter, a map of local variable names to values, and a stack of values.
Harmony makes no difference between lists and tuples and implements
both as dictionaries from integers to values.
So <{[7, 4] = (7, 4) = { 0: 7, 1: 4 }}>.
Note that <{[7, 4][0] = 7}>, as expected.
The empty dictionary is represented as either <{()}> or <{[]}>
(<{{}}> is the empty set).

Except for <{choose}>, any operation on values is deterministic and
defined in the formal specification of the Harmony virtual machine.
For example, like Python, Harmony supports merging of dictionaries
using the union operator (<{|}>), but, unlike Python, Harmony defines
what happens when two dictionaries have the same key but different values.
In that case, Harmony will use the maximum value as defined above.
For dictionary  intersection, Harmony uses the minimum value instead.
Doing so has make dictionary union and intersection deterministic and
commutative.  Moreover, Harmony represents multisets as dictionaries
of values to multiplicities.  Using Harmony's rules on dictionary union
and intersection, union and intersection on multisets are correctly
defined.

\subsection{State}

The state of the HVM consists of three variables:
\begin{compactitem}
\item a dictionary of shared variable names to values;
\item a bag (multiset) of contexts, one for each thread;
\item a set of \emph{active} contexts.
\end{compactitem}

Harmony uses a multibag to keep track of the states of the threads
because threads can be in the same state.
Threads do not have unique identifiers, reducing state explosion in
the model checker.

A context is active if it can make a transition.
Contexts can be atomic or not---the HVM prevents multiple atomic
contexts from being atomic simultaneously.  Therefore, the active set
either contains a single atomic context or it contains all contexts
in the domain of the context bag.

The initial state consists of an empty dictionary of shared variables and
a single atomic context with program
counter 0 in both the context bag and the active set.

Harmony also allows the user to specify a determistic finite automaton
(DFA) to check the legality of the output of the program to be
checked.  In that case, the state of the automaton is also made
part of the HVM state, so that the HVM maintains the product of the
program state and the DFA state.

\subsection{Transitions}

The HVM makes a transition by executing an HVM instruction using
one of the contexts in the active set.  There are about 30 basic
transitions, which, for this paper, we classify as follows:

\begin{compactitem}
\item \emph{basic operations}: do a simple operation to a context
such as pushing a value onto its stack, and increase its program
counter by one.
\item \emph{jumps}: to implement loops.
\item \texttt{Choose}: nondetermistic selection from a set.
\item \texttt{Apply}: to call a method \emph{or} to index into a dictionary.
\item \texttt{Frame/Return}: method start/stop.
\item \texttt{Spawn}: create a new thread.
\item \texttt{AtomicInc/AtomicDec}: modify the atomic counter of the context.
\item \texttt{SetIntLevel}: enable/disable interrupts.
\item \texttt{Stop/Go}: manipulating continuations.
\item \texttt{Assert}: check a value.
\item \texttt{Print}: add a value to the print log.
\end{compactitem}

Each transition modifies at least the context bag and set of active
contexts.
A few operations (\texttt{Store}, \texttt{Stop}, and \texttt{Del})
also modify one of the shared variables.

\paragraph{Choose.} \texttt{Choose} pops a set value of the stack
and pushes a selected element back onto the stack.  The model checker
tries each selection.

\paragraph{Apply.}  \texttt{Apply} pops two values $f$ and $x$ of the stack,
\emph{applies} $x$ to $f$, and pushes the resulting value back onto the
stack.  What \emph{applies} means depends on the type of $f$.  If $f$ is
a PC value, then it means invoking method $f$: it pushes the return address
and $x$ onto the stack and set the program counter to $f$.  If $f$ is a
dictionary, then it means pushing the value corresponding to key $x$ onto
the stack.  This way, a dictionary acts much like a method that maps keys
to values.  If $f$ is a string, then the operation returns the $x^{th}$
character of the string.

\paragraph{Frame/Return.}  \texttt{Frame} is the first operation of
a method and \texttt{Return} its last.  \texttt{Frame} pops a value of
the stack and assigns it to the argument (or argument list) of the
method.  It also saves the local variables onto the stack and set the
value of the <{result}> variable to <{None}>.  The operation of
\texttt{Return} depends on whether the stack is empty of not.  If empty
\texttt{Return} terminates the thread by removing the context from the
context bag replacing the active set with the domain of the context bag.
If the stack is not empty, then the saved local variables are popped
and restored, the return address is popped and assigned to the
program counter, and the value of <{result}> is pushed onto the
stack.

\paragraph{Spawn.}  Spawn pops a program counter and argument from the
stack and uses them to create a new context.  The new context is added
to the context bag.  Also, if the current context is not atomic, then
the new context is also added to the active set.

\paragraph{AtomicInc/AtomicDec.}  A context contains a counter that,
if non-zero, puts the context in atomic mode.
<{atomically}> statements can be nested: at the beginning, the
counter is incremented; at the end, it is decremented.
When incremented from 0 to 1, the operation replaces the active
set of context with just the current context.  When decremented
from 1 to 0, the active set is replaced with the union of the
new context and the domain of the context bag.

\paragraph{SetIntLevel.}  A context contains a boolean that determines
if interrupts are enabled or not.  \texttt{SetIntLevel} pops the
new interrupt level and pushes the old.

\paragraph{Stop/Go.}  \texttt{Stop} saves the current context (with
its program counter incremented) in a specified shared location (usually the
tail of a queue) and removes the context from the context bag and active set.
If the context was atomic (which is usually the case), the active set is
replaced with the domain of the context bag.  Even though its atomic counter
is not zero, the stopped context is not considered atomic at this time.
\texttt{Go} pops a context value and a return value of the stack and
pushes the return value onto the stack of the popped context, and adds
the context to the context bag.  If the current context is not atomic,
then the restored context is also added to the active set.

\paragraph{Assert.}  \texttt{Assert} pops a boolean value and increments
the program counter.  If the value is <{False}>, the HVM aborts.

\paragraph{Print.}  \texttt{Print} pops a value of the stack and increments
the program counter.  In case a behavior automaton has been specified, the
value is applied to the DFA state and checked for validity.
To reduce state explosion, the HVM does not keep track of the value itself
in the state (like keeping the value in a shared list as part of the state).

\subsection{Model Checker}

\emph{Charm}, the Harmony model checker is an explicit state model
checker that computes a \emph{Kripke structure} of states reachable
from the initial state in a breadth-first manner, stopping only if
it encounters an error (such as divide-by-zero or a failing assertion)
or until there are no more new states.

There are three sources of nondetermism in Harmony: \texttt{Choose}
operations, thread interleaving, and interrupts.
When it comes to interleaving, an important observation is that
local operations on the state of a context (updates to its program
counter, local variables, or stack) are not visible to other threads.
An important optimization that significantly
reduces the size of the set of generated states is to treat a
sequence of operations as atomic if only its first operation is an
operation that accesses the shared state (\texttt{Load}, \texttt{Store},
\texttt{Del}, or \texttt{Stop}) or a \texttt{Choose} or \texttt{Print}
operation.  We call such operations \emph{breakable}.
Note that this is essentially a form of Partial Order Reduction.
Reducing the state space this way is highly effective for Harmony.
For example, when model checking Peterson's algorithm expressed in
Harmony, the number of states is reduced from 7927 to 104 states.
In the case of the Knuth-Yao algorithm (which is not concurrent but
involves choices), the number of states is reduced from 258 states
to 14.

Given a state and a context, Charm first applies the first instruction
to the state.  Then it continues to apply instructions as long as
the active set is the singleton set (such as when the thread is in
atomic mode) or, if not, as long as the next instruction is not
breakable.  Only the resulting state is added to the Kripke structure,
and the edge indicates the starting context.  During this loop, Charm
does check if the same state recurs---if so it aborts
and reports an infinite loop.

In the case the first instruction is a \texttt{Choose} instruction,
Charm will try all possible choices for the set value
on top of the stack.  If not, Charm will also check to
see if a trap is outstanding and interrupts are enabled.  If so,
Charm will try an interrupt transition as well.

\subsection{Data Race Detection}

A data race occurs when two or more threads simultaneously try to
access the same shared data location, at least one of which is a
\texttt{Store}, \texttt{Stop}, or \texttt{Del} instruction.  Harmony
only considers this a problem it at least one of those threads is
not in atomic mode.  After all, we do not want to consider accesses
to a spinlock as a problem.  Also, the Harmony language allows
shared variables to be tagged as \emph{sequentially consistent},
effectively turning off data race detection.  Charm maintains on
the edges of the Kripke a list of accesses that were made during
the transition.  After all transitions from a state have been
computed, Charm checks for data races.

\section{Analysis}

After running the Charm model checker, there are two cases to
consider.  If Charm aborted due to some problematic transition,
then Charm reports the shortest path as a so-called \emph{counter-example}.
If not, the resulting graph is analyzed for various other problems,
including deadlock, busy waiting, and executions
that ended in a state that is not considered final according to
behavior DFA if specified.  We detail below how these problems are
found.

\paragraph{Deadlock and Faulty Behavior.}

Harmony transforms the Kripke structure into a DAG of its strongly
connected components.  The states in the sink components of this
DAG can be considered the terminal states of the Harmony program.
States in which the context bag is empty represent states in which
all threads have terminated.
In the case the context bag is not empty, we check if there are any
non-\emph{eternal} contexts.  If so, Harmony reports a \emph{deadlock}.
Harmony programmers can specify that certain threads are eternal,
such as server threads that operate in an infinite loop waiting for
requests.
If there is no deadlock and a behavior automaton was specified,
Harmony also checks Harmony checks if the automaton is in a
terminal state.  If not, a \emph{behavior violation} is reported.

\paragraph{Active Busy Waiting.}

A thread is considered \emph{blocked} if it can only make progress
(modify the state) if another thread makes a transition first.
This is not always a problem: a thread waiting on a lock in a spinloop
is a common way of synchronizing threads, and Harmony does not report
such issues.

A thread is considered \emph{actively busy waiting} if it cannot
escape it strongly connected component without another thread
updating the shared state first.  A common example of this is a
synchronization algorithm that checks for a condition in a loop,
acquiring and releasing the lock each time.  Harmony checks each
strongly connected component for the existence of such situations.

\paragraph{Incomplete Behavior.}

The Kripke structure can be considered as a non-deterministic
automaton, with on each edge zero or more \emph{symbols} (values
that were printed.  If a behavior automaton was specified,
then there are now two automata: the specified automaton
${\mathcal Spec}$ that was presented to Charm as an input as
part of the \emph{specification}, and the generated automaton
${\mathcal Impl}$ that was generated by the given Harmony
\emph{implementation}.  Harmony already checks on-the-fly whether
${\mathcal Impl} \subseteq {\mathcal Spec}$, that is, that every
behavior (sequence of symbols) of the implementation is also a
behavior of the specification.  Harmony also checks if
${\mathcal Spec} \subset {\mathcal Impl}$ and, if so,
produces a warning.
Although not current done, it is possible to compute
${\mathcal Spec}~\backslash~{\mathcal Impl}$
to generate an automaton for all behaviors allowed by the
specification that are not in the implementation.

Having such behaviors is not always a problem, but it can be.  For
example, a reader/writer lock implemented as a plain lock meets the
specification of a reader/writer lock, but it does not allow multiple
readers in the critical section.  Unfortunately, checking ${\mathcal
Spec} \subset {\mathcal Impl}$ does not scale well and can only be
done for relatively small Kripke structures.

\bibliographystyle{alpha}
\bibliography{paper}

\end{document}
