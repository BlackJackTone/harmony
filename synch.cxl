def tas(self):
    atomic:
        var oldval = ^self;
        ^self := True;
        self := oldval;
    ;
;
def Lock(self):
    self := False;
;
def lock(lk):
    while tas(lk):
        pass;
    ;
;
def unlock(lk):
    ^lk := False;
;
def Condition(self):
    self := dict{ .lock: self, .waiters: {} };
;
def wait(c):
    var pid = getpid();
    (^c).waiters := (^c).waiters union { pid };
    while pid in (^c).waiters:
        call unlock((^c).lock);
        call lock((^c).lock);
    ;
;
def notify(c):
    if (^c).waiters != {}:
        var x = choose((^c).waiters);
        (^c).waiters := (^c).waiters \ {x};
    ;
;
def notifyAll(c):
    (^c).waiters := {};
;
def Semaphore(cnt):
    pass;
;
def P(sema):
    var blocked = True;
    while blocked:
        atomic:
            if (^sema) > 0:
                ^sema := (^sema) - 1;
                blocked := False;
            ;
        ;
    ;
;
def V(sema):
    atomic:
        ^sema := (^sema) + 1;
    ;
;
